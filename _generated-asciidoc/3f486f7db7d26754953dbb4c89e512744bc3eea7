git-log(1)
==========

名称
--
git-log - 显示提交日志


概述
--
[verse]
'git log' [<options>] [<revision-range>] [[--] <path>...]

描述
--
显示提交日志。

:git-log: 1


[WARNING]
====
Missing `zh_HANS-CN/rev-list-description.txt`

See original version for this content.
====

[]

该命令采用适用于 linkgit:git-rev-list[1] 命令的选项来控制显示的内容和方式，以及适用于 linkgit:git-diff[1] 命令的选项来控制每次提交引入的更改的显示方式。


选项
--

--follow::
	继续列出文件的历史记录，包括重命名之后的情况（仅适用于单个文件）。

--no-decorate::
--decorate[=short|full|auto|no]::
	Print out the ref names of any commits that are shown. If 'short' is specified, the ref name prefixes 'refs/heads/', 'refs/tags/' and 'refs/remotes/' will not be printed. If 'full' is specified, the full ref name (including prefix) will be printed. If 'auto' is specified, then if the output is going to a terminal, the ref names are shown as if 'short' were given, otherwise no ref names are shown. The option `--decorate` is short-hand for `--decorate=short`. Default to configuration value of `log.decorate` if configured, otherwise, `auto`.

--decorate-refs=<pattern>::
--decorate-refs-exclude=<pattern>::
	对于每个候选引用，在以下情况下不要将其用于装饰（decorate）：若它与`--decorate-refs-exclude`指定的任何模式匹配，或者若它不与`--decorate-refs`指定的任何模式匹配。配置选项`log.excludeDecoration`允许从装饰中排除引用，但是在`log.excludeDecoration`中的匹配项将被`--decorate-refs`模式中的显式指定所覆盖。
+
如果没有给出这些选项或配置设置中的任何一个，那么如果引用与 `HEAD` 、`refs/heads/`、`refs/remotes/` 、`refs/stash/` 或 `refs/tags/` 匹配，则使用引用作为装饰。

--clear-decorations::
	当指定了该选项时，它会清除所有先前的 `--decorate-refs` 或 `--decorate-refs-exclude` 选项，并放宽默认的装饰过滤器以包括所有引用。如果配置值 `log.initialDecorationSet` 设置为 `all`，则假定使用此选项。

--source::
	打印出通过命令行给定的引用名称，以便触及每个提交。

--[no-]mailmap::
--[no-]use-mailmap::
	使用 mailmap 文件将作者和提交者的名称和电子邮件地址映射到规范的真实名称和电子邮件地址。请参阅 linkgit:git-shortlog[1]。

--full-diff::
	Without this flag, `git log -p <path>...` shows commits that touch the specified paths, and diffs about the same specified paths. With this, the full diff is shown for commits that touch the specified paths; this means that "<path>..." limits only commits, and doesn't limit diff for those commits.
+
请注意，这会影响所有基于差异的输出类型。例如：由 `--stat` 等产生的输出。

--log-size::
	Include a line ``log size <number>'' in the output for each commit, where <number> is the length of that commit's message in bytes. Intended to speed up tools that read log messages from `git log` output by allowing them to allocate space in advance.



[WARNING]
====
Missing `zh_HANS-CN/line-range-options.txt`

See original version for this content.
====

[]

<revision-range>::
	Show only commits in the specified revision range. When no <revision-range> is specified, it defaults to `HEAD` (i.e. the whole history leading to the current commit). `origin..HEAD` specifies all the commits reachable from the current commit (i.e. `HEAD`), but not from `origin`. For a complete list of ways to spell <revision-range>, see the 'Specifying Ranges' section of linkgit:gitrevisions[7].

[--] <path>...::
	Show only commits that are enough to explain how the files that match the specified paths came to be. See 'History Simplification' below for details and other simplification modes.
+
当出现混淆时，路径可能需要以`--`为前缀，以便将其与选项或修订范围分开。

承诺限制
~~~~

除了使用描述中解释的特殊符号指定应列出的提交范围，还可以应用额外的提交限制。

Using more options generally further limits the output (e.g. `--since=<date1>` limits to commits newer than `<date1>`, and using it with `--grep=<pattern>` further limits to commits whose log message has a line that matches `<pattern>`), unless otherwise noted.

请注意，这些都是在提交排序和格式化选项之前应用的，如 `--reverse`。

-<数>::
-n <数量>::
--max-count=<数量>::
	限制输出的提交数量。

--skip=<数量>::
	在开始显示提交输出之前，跳过'数'的提交。

--since=<日期>::
--after=<日期>::
	显示比某一特定日期更近的提交。

--since-as-filter=<日期>::
	显示所有比指定日期更近的提交。这将访问该范围内的所有提交，而不是停在第一个比指定日期更早的提交。

--until=<日期>::
--before=<日期>::
	显示超过特定日期的提交。

ifdef::git-rev-list[]
--max-age=<时间戳>::
--min-age=<时间戳>::
	将提交的结果限制在指定的时间范围内。
endif::git-rev-list[]

--author=<模式>::
--committer=<模式>::
	Limit the commits output to ones with author/committer header lines that match the specified pattern (regular expression). With more than one `--author=<pattern>`, commits whose author matches any of the given patterns are chosen (similarly for multiple `--committer=<pattern>`).

--grep-reflog=<模式>::
	Limit the commits output to ones with reflog entries that match the specified pattern (regular expression). With more than one `--grep-reflog`, commits whose reflog message matches any of the given patterns are chosen. It is an error to use this option unless `--walk-reflogs` is in use.

--grep=<模式>::
	Limit the commits output to ones with a log message that matches the specified pattern (regular expression). With more than one `--grep=<pattern>`, commits whose message matches any of the given patterns are chosen (but see `--all-match`).
ifndef::git-rev-list[]
+
当 `--notes` 生效时，笔记中的信息被匹配，就像它是日志信息的一部分。
endif::git-rev-list[]

--all-match::
	将输出的提交限制在符合所有给定`--grep`的提交，而不是至少符合一个的提交。

--invert-grep::
	限定输出的提交信息与 `--grep=<模式>`指定的模式不匹配。

-i::
--regexp-ignore-case::
	匹配正则表达式的限制模式，不考虑字母大小写。

--basic-regexp::
	将限制性模式视为基本的正则表达式；这是默认的。

-E::
--extended-regexp::
	将限制性模式视为扩展的正则表达式，而不是默认的基本正则表达式。

-F::
--fixed-strings::
	将限制性模式视为固定字符串（不要将模式解释为正则表达式）。

-P::
--perl-regexp::
	将限制性模式视为与Perl兼容的正则表达式。
+
对这些类型的正则表达式的支持是一个可选的编译时依赖。如果Git在编译时没有对它们的支持，提供这个选项将导致它死亡。

--remove-empty::
	当一个给定的路径从树上消失时停止。

--merges::
	只打印合并后的提交。这与`--min-parents=2`完全相同。

--no-merges::
	不打印有一个以上父级的提交。这与`--max-parents=1`完全相同。

--min-parents=<数量>::
--max-parents=<数量>::
--no-min-parents::
--no-max-parents::
	Show only commits which have at least (or at most) that many parent commits. In particular, `--max-parents=1` is the same as `--no-merges`, `--min-parents=2` is the same as `--merges`. `--max-parents=0` gives all root commits and `--min-parents=3` all octopus merges.
+
`--no-min-parents` and `--no-max-parents` reset these limits (to no limit) again. Equivalent forms are `--min-parents=0` (any commit has 0 or more parents) and `--max-parents=-1` (negative numbers denote no upper limit).

--first-parent::
	When finding commits to include, follow only the first parent commit upon seeing a merge commit. This option can give a better overview when viewing the evolution of a particular topic branch, because merges into a topic branch tend to be only about adjusting to updated upstream from time to time, and this option allows you to ignore the individual commits brought in to your history by such a merge.
ifdef::git-log[]
+
这个选项也改变了合并提交的默认差异格式为 "first-parent"，详见"--diff-merges=first-parent"。
endif::git-log[]

--exclude-first-parent-only::
	When finding commits to exclude (with a '{caret}'), follow only the first parent commit upon seeing a merge commit. This can be used to find the set of changes in a topic branch from the point where it diverged from the remote branch, given that arbitrary merges can be valid topic branch changes.

--not::
	Reverses the meaning of the '{caret}' prefix (or lack thereof) for all following revision specifiers, up to the next `--not`. When used on the command line before --stdin, the revisions passed through stdin will not be affected by it. Conversely, when passed via standard input, the revisions passed on the command line will not be affected by it.

--all::
	假设`refs/`中的所有参考文献，连同`HEAD`一起，在命令行中被列为'<commit>'。

--branches[=<模式>]::
	假设`refs/heads`中的所有 refs 在命令行中被列为 '<commit>'。如果给出了'<pattern>'，将分支限制在与给定的shell glob相匹配的分支。如果pattern缺少'?'、'{asterisk}'或'['，则末尾的'/{asterisk}'是暗示的。

--tags[=<模式>]::
	假设`refs/tags`中的所有参考文献在命令行中被列为'<commit>'。如果给出了'<pattern>'，将标签限制在与给定的shell glob相匹配的标签。如果pattern缺少'?'、'{asterisk}'或'['，则暗示最后的'/{asterisk}'。

--remotes[=<模式>]::
	Pretend as if all the refs in `refs/remotes` are listed on the command line as '<commit>'. If '<pattern>' is given, limit remote-tracking branches to ones matching given shell glob. If pattern lacks '?', '{asterisk}', or '[', '/{asterisk}' at the end is implied.

--glob=<通配符模式>::
	假设所有与shell glob '<glob-pattern>相匹配的refs在命令行中被列为'<commit>'。前面的'refs/'，如果缺少的话会自动预加。如果模式中缺少'?'、'{asterisk}'或'['，则在结尾处隐含'/{asterisk}'。

--exclude=<通配符模式>::

	不包括匹配"<glob-pattern>"的参考文献，否则下一个`--all`、`--branches`、`--tags`、`--remotes`或`--glob`会考虑这些参考文献。重复这个选项可以累积排除模式，直到下一个`----all`、`---branches`、`---tags`、`---remotes`或`---glob`选项（其他选项或参数不清除累积模式）。
+
当应用于 `--branches`、 `--tags` 或 `--remotes` 时，所给出的模式不应以 `refs/heads`、`refs/tags` 或 `refs/remotes` 开头；当应用于 `--glob` 或 `--all` 选项时，必须以 `refs/` 开头。如果要使用尾部的 '/{asterisk}'，则必须明确给出。

--exclude-hidden=[fetch|receive|uploadpack]::
	通过查阅相应的 `fetch.hideRefs` 、`receive.hideRefs` 或 `uploadpack.hideRefs` 配置和 `transfer.hideRefs` 配置（参见 linkgit:git-config[1]），不要包含会被 `git-fetch` 、`git-receive-pack` 或 `git-upload-pack` 隐藏的引用。该选项会影响下一个伪引用选项 `--all` 或 `--glob`，并在处理后清除。

--reflog::
	假设reflogs提到的所有对象都在命令行中被列为`<commit>`。

--alternate-refs::
	Pretend as if all objects mentioned as ref tips of alternate repositories were listed on the command line. An alternate repository is any repository whose object directory is specified in `objects/info/alternates`. The set of included objects may be modified by `core.alternateRefsCommand`, etc. See linkgit:git-config[1].

--single-worktree::
	By default, all working trees will be examined by the following options when there are more than one (see linkgit:git-worktree[1]): `--all`, `--reflog` and `--indexed-objects`. This option forces them to examine the current working tree only.

--ignore-missing::
	在看到输入中无效的对象名称时，假装没有给出坏的输入。

ifndef::git-rev-list[]
--bisect::
	假设坏的二分法参考文献`refs/bisect/bad`被列出，并且在命令行中假设它后面是`--not`和好的二分法参考文献`refs/bisect/good-*`。
endif::git-rev-list[]

--stdin::
	除从命令行获取参数外，还可从标准输入读取参数。它接受提交和伪选项，如 `--all` 和 `--glob=`。当看到 `--` 分隔符时，下面的输入将被视为路径并用于限制结果。通过标准输入读取的 `--not` 等标志只适用于以相同方式传递的参数，不会影响后续的命令行参数。

ifdef::git-rev-list[]
--quiet::
	Don't print anything to standard output. This form is primarily meant to allow the caller to test the exit status to see if a range of objects is fully connected (or not). It is faster than redirecting stdout to `/dev/null` as the output does not have to be formatted.

--disk-usage::
--disk-usage=human::
	Suppress normal output; instead, print the sum of the bytes used for on-disk storage by the selected commits or objects. This is equivalent to piping the output into `git cat-file --batch-check='%(objectsize:disk)'`, except that it runs much faster (especially with `--use-bitmap-index`). See the `CAVEATS` section in linkgit:git-cat-file[1] for the limitations of what "on-disk storage" means. With the optional value `human`, on-disk storage size is shown in human-readable string(e.g. 12.24 Kib, 3.50 Mib).
endif::git-rev-list[]

--cherry-mark::
	就像`--cherry-pick`（见下文），但用`=`标记同等的提交，而不是省略，用`+`标记不同等的提交。

--cherry-pick::
	当提交的集合有对称差异时，省略任何与 "另一边 "的另一个提交相同的提交。
+
例如，如果你有两个分支，`A` 和 `B`，通常的方法是用`--左--右`列出其中一边的所有提交（见下面关于`--left-right`选项的描述）。然而，它显示的是从另一个分支中偷梁换柱的提交（例如，''3rd on b'' 可能是从分支 A 中偷梁换柱的）。有了这个选项，这样的提交对将从输出中排除。

--left-only::
--right-only::
	只列出对称性差异各自一侧的提交，即只列出那些通过 `--left-right` 标记的 `<` 或 `>`。
+
For example, `--cherry-pick --right-only A...B` omits those commits from `B` which are in `A` or are patch-equivalent to a commit in `A`. In other words, this lists the `+` commits from `git cherry A B`. More precisely, `--cherry-pick --right-only --no-merges` gives the exact list.

--cherry::
	`--right-only --cherry-mark --no-merges`的同义词；有助于将输出限制在我们这边的提交，并标记那些已经应用到分叉历史的另一边的提交，`git log --cherry upstream...mybranch`，类似于`git cherry upstream mybranch`。

-g::
--walk-reflogs::
	Instead of walking the commit ancestry chain, walk reflog entries from the most recent one to older ones. When this option is used you cannot specify commits to exclude (that is, '{caret}commit', 'commit1..commit2', and 'commit1\...commit2' notations cannot be used).
+
With `--pretty` format other than `oneline` and `reference` (for obvious reasons), this causes the output to have two extra lines of information taken from the reflog. The reflog designator in the output may be shown as `ref@{Nth}` (where `Nth` is the reverse-chronological index in the reflog) or as `ref@{timestamp}` (with the timestamp for that entry), depending on a few rules:
+
--
1. 如果起点被指定为`ref@{Nth}`，显示索引格式。
+
2. 如果起点被指定为`ref@{now}`，显示时间戳格式。
+
3. 如果两者都没有使用，但在命令行中给出了`--date`，则按照`--date`所要求的格式显示时间戳。
+
4. 否则，显示索引格式。
--
+
Under `--pretty=oneline`, the commit message is prefixed with this information on the same line. This option cannot be combined with `--reverse`. See also linkgit:git-reflog[1].
+
在`--pretty=reference`下，这些信息将完全不显示。

--merge::
	在合并失败后，显示触及有冲突的文件且不存在于所有要合并的头的参考文件。

--boundary::
	输出排除的边界提交。边界提交的前缀是"-"。

ifdef::git-rev-list[]
--use-bitmap-index::

	尝试使用包位图索引（如果有的话）来加快遍历的速度。注意，当使用`--objects` 选项进行遍历时，目录树和 blobs 不会打印出它们的相关路径。

--progress=<头信息>::
	在考虑对象时在stderr上显示进度报告。`<标题>`文本将在每次进度更新时打印。
endif::git-rev-list[]

简化历史
~~~~

有时你只对历史的一部分感兴趣，例如修改某个<路径>的提交。但 "历史简化 "有两部分，一部分是选择提交，另一部分是如何做，因为有各种策略来简化历史。

以下选项选择要显示的提交：

<paths>::
	修改给定<路径>的提交会被选中。

--simplify-by-decoration::
	被某个分支或标签引用的提交被选中。

请注意，可以显示额外的提交，以提供一个有意义的历史。

以下选项会影响简化的执行方式：

默认模式::
	将历史简化为解释树的最终状态的最简单的历史。最简单的原因是，如果最终结果相同，它会修剪一些侧枝（即合并具有相同内容的分支）

--show-pulls::
	包括默认模式下的所有提交，但也包括任何与第一个父分支不相干但与后来的父分支相干的合并提交。这种模式有助于显示 "首次引入 "某个分支的合并提交。

--full-history::
	与默认模式相同，但不修剪一些历史记录。

--dense::
	只显示所选的提交，再加上一些才有意义的历史。

--sparse::
	简化历史中的所有提交都会显示出来。

--simplify-merges::
	为`--full-history`增加了一个选项，可以从结果的历史中删除一些不必要的合并，因为没有选定的提交对这次合并有贡献。

--ancestry-path[=<提交>]::
	When given a range of commits to display (e.g. 'commit1..commit2' or 'commit2 {caret}commit1'), only display commits in that range that are ancestors of <commit>, descendants of <commit>, or <commit> itself. If no commit is specified, use 'commit1' (the excluded part of the range) as <commit>. Can be passed multiple times; if so, a commit is included if it is any of the commits given or if it is an ancestor or descendant of one of them.

以下是更详细的解释。

Suppose you specified `foo` as the <paths>. We shall call commits that modify `foo` !TREESAME, and the rest TREESAME. (In a diff filtered for `foo`, they look different and equal, respectively.)

In the following, we will always refer to the same example history to illustrate the differences between simplification settings. We assume that you are filtering for a file `foo` in this commit graph:
-----------------------------------------------------------------------
	  .-A---M---N---O---P---Q
	 /     /   /   /   /   /
	I     B   C   D   E   Y
	 \   /   /   /   /   /
	  `-------------'   X
-----------------------------------------------------------------------
The horizontal line of history A---Q is taken to be the first parent of each merge. The commits are:

* `I`是初始提交，其中`foo`存在，内容是`asdf''，文件`quux`存在，内容是`quux''。初始提交与空树比较，所以`I`是！`TREESAME。

* 在`A`中，`foo`只包含`foo''。

* `B` contains the same change as `A`. Its merge `M` is trivial and hence TREESAME to all parents.

* `C`没有改变`foo`，但是它的合并`N`将其改为`foobar''，所以它与任何父类都不存在TREESAME。

* `D`将`foo`设置为`baz''。它的合并项`O`将`N`和`D`的字符串合并为`foobarbaz''；也就是说，它与任何父类都不是TREESAME。

* `E`将`quux`改为`xyzzy''，其合并的`P`将这些字符串合并为`quux xyzzy''。`P'与`O'的关系是TREESAME，但与`E'不是。

* `X`是一个独立的根提交，添加了一个新文件`side`，`Y`修改了它。`Y`与`X`同为TREESAME。它的合并文件`Q`在`P`上添加了`side`，`Q`与`P`是同源，但与`Y`不是同源。

`rev-list`在历史中倒退，根据是否使用`--full-history`和/或父代重写（通过`--parents`或`--children`），包括或排除提交。以下设置是可用的。

默认模式::
	Commits are included if they are not TREESAME to any parent (though this can be changed, see `--sparse` below). If the commit was a merge, and it was TREESAME to one parent, follow only that parent. (Even if there are several TREESAME parents, follow only one of them.) Otherwise, follow all parents.
+
这将实现：
+
-----------------------------------------------------------------------
	  .-A---N---O
	 /     /   /
	I---------D
-----------------------------------------------------------------------
+
Note how the rule to only follow the TREESAME parent, if one is available, removed `B` from consideration entirely. `C` was considered via `N`, but is TREESAME. Root commits are compared to an empty tree, so `I` is !TREESAME.
+
父/子关系只有在使用 `--parents` 选项的情况下才能看到，但这并不影响在默认模式下选择的提交，所以我们显示了父行。

--full-history 无父级重写的完整历史记录::
	This mode differs from the default in one point: always follow all parents of a merge, even if it is TREESAME to one of them. Even if more than one side of the merge has commits that are included, this does not imply that the merge itself is! In the example, we get
+
-----------------------------------------------------------------------
	I  A  B  N  D  O  P  Q
-----------------------------------------------------------------------
+
`M` was excluded because it is TREESAME to both parents. `E`, `C` and `B` were all walked, but only `B` was !TREESAME, so the others do not appear.
+
请注意，如果没有父子重写，其实是不可能谈论提交之间的父子关系的，所以我们显示它们是不相连的。

--full-history 带父级重写功能的全历史记录::
	普通的提交只有当它们是！TREESAME时才会被包括在内（尽管这一点可以改变，见下面的`--sparse`）。
+
Merges are always included. However, their parent list is rewritten: Along each parent, prune away commits that are not included themselves. This results in
+
-----------------------------------------------------------------------
	  .-A---M---N---O---P---Q
	 /     /   /   /   /
	I     B   /   D   /
	 \   /   /   /   /
	  `-------------'
-----------------------------------------------------------------------
+
Compare to `--full-history` without rewriting above. Note that `E` was pruned away because it is TREESAME, but the parent list of P was rewritten to contain `E`'s parent `I`. The same happened for `C` and `N`, and `X`, `Y` and `Q`.

除了上述设置外，你还可以改变 TRESAME 是否会影响收录：

--dense::
	如果不与任何父类有TREESAME关系，则包括走过的承诺。

--sparse::
	所有走过的提交都包括在内。
+
请注意，如果没有`--full-history`，这仍然可以简化合并：如果父代之一是TREESAME，我们只跟随这个父代，所以合并的其他方面永远不会被走。

--simplify-merges::
	首先，按照`--full-history`与父级改写的相同方式建立一个历史图（见上文）。
+
然后根据以下规则将每个提交的 `C` 简化为最终历史中的替换 `C`：
+
--
* 将 "C "设为 "C"。
+
* Replace each parent `P` of `C'` with its simplification `P'`. In the process, drop parents that are ancestors of other parents or that are root commits TREESAME to an empty tree, and remove duplicates, but take care to never drop all parents that we are TREESAME to.
+
* If after this parent rewriting, `C'` is a root or merge commit (has zero or >1 parents), a boundary commit, or !TREESAME, it remains. Otherwise, it is replaced with its only parent.
--
+
The effect of this is best shown by way of comparing to `--full-history` with parent rewriting. The example turns into:
+
-----------------------------------------------------------------------
	  .-A---M---N---O
	 /     /       /
	I     B       D
	 \   /       /
	  `---------'
-----------------------------------------------------------------------
+
注意 `N` 、`P` 和 `Q` 与 `--full-history` 的主要区别：
+
--
* `N`'s parent list had `I` removed, because it is an ancestor of the other parent `M`. Still, `N` remained because it is !TREESAME.
+
* `P`'s parent list similarly had `I` removed. `P` was then removed completely, because it had one parent and is TREESAME.
+
* `Q`的父列表中有`Y`简化为`X`。然后`X`被删除，因为它是一个TREESAME根。然后`Q`被完全删除，因为它有一个父级，是TREESAME。
--

还有一种简化模式可用：

--ancestry-path[=<提交>]::
	将显示的提交限制在<提交>的祖先，或<提交>的后代，或<提交>本身。
+
作为一个用例，请考虑以下提交历史：
+
-----------------------------------------------------------------------
	    D---E-------F
	   /     \       \
	  B---C---G---H---I---J
	 /                     \
	A-------K---------------L--M
-----------------------------------------------------------------------
+
有规律的 "D...M "会计算出作为`M`的祖先的提交集合，但不包括作为`D`的祖先的提交。这对了解`M'的历史在`D'之后发生了什么很有用，也就是说`M'有什么东西是`D'没有的'。这个例子中的结果是所有的提交，除了`A`和`B`（当然还有`D`本身）。
+
When we want to find out what commits in `M` are contaminated with the bug introduced by `D` and need fixing, however, we might want to view only the subset of 'D..M' that are actually descendants of `D`, i.e. excluding `C` and `K`. This is exactly what the `--ancestry-path` option does. Applied to the 'D..M' range, it results in:
+
-----------------------------------------------------------------------
		E-------F
		 \       \
		  G---H---I---J
			       \
				L--M
-----------------------------------------------------------------------
+
我们也可以用`--ancestry-path=D`来代替`--ancestry-path`，这在应用于'D...M'范围时意思相同，只是更加明确。
+
If we instead are interested in a given topic within this range, and all commits affected by that topic, we may only want to view the subset of `D..M` which contain that topic in their ancestry path. So, using `--ancestry-path=H D..M` for example would result in:
+
-----------------------------------------------------------------------
		E
		 \
		  G---H---I---J
			       \
				L--M
-----------------------------------------------------------------------
+
而`--ancestry-path=K D...M`会形成以下结果
+
-----------------------------------------------------------------------
		K---------------L--M
-----------------------------------------------------------------------

在讨论另一个选项，`--show-pulls`之前，我们需要创建一个新的历史实例。

用户在查看简化的提交历史时经常遇到的一个问题是，他们知道的对某个文件的修改提交并没有出现在该文件的简史中。让我们演示一个新的例子，并说明`--full-history`和`--simplify-merges`等选项在这种情况下是如何工作的：

-----------------------------------------------------------------------
	  .-A---M-----C--N---O---P
	 /     / \  \  \/   /   /
	I     B   \  R-'`-Z'   /
	 \   /     \/         /
	  \ /      /\        /
	   `---X--'  `---Y--'
-----------------------------------------------------------------------

For this example, suppose `I` created `file.txt` which was modified by `A`, `B`, and `X` in different ways. The single-parent commits `C`, `Z`, and `Y` do not change `file.txt`. The merge commit `M` was created by resolving the merge conflict to include both changes from `A` and `B` and hence is not TREESAME to either. The merge commit `R`, however, was created by ignoring the contents of `file.txt` at `M` and taking only the contents of `file.txt` at `X`. Hence, `R` is TREESAME to `X` but not `M`. Finally, the natural merge resolution to create `N` is to take the contents of `file.txt` at `R`, so `N` is TREESAME to `R` but not `C`. The merge commits `O` and `P` are TREESAME to their first parents, but not to their second parents, `Z` and `Y` respectively.

当使用默认模式时，`N'和`R`都有一个TREESAME父级，所以这些边被展示出来，其他边被忽略。由此产生的历史图是：

-----------------------------------------------------------------------
	I---X
-----------------------------------------------------------------------

当使用 `--full-history` 选项时，Git 会行走每条边。这将发现提交 `A` 和 `B` 以及合并 `M`，但也将揭示合并提交 `O` 和 `P` 。通过父级改写，得到的图是：

-----------------------------------------------------------------------
	  .-A---M--------N---O---P
	 /     / \  \  \/   /   /
	I     B   \  R-'`--'   /
	 \   /     \/         /
	  \ /      /\        /
	   `---X--'  `------'
-----------------------------------------------------------------------

这里，合并提交 `O` 和 `P` 带来了额外的输出，因为它们实际上并没有对 `file.txt` 做出改变。他们只是合并了一个基于 `file.txt` 旧版本的主题。这是在使用工作流程的仓库中常见的问题，在工作流程中，许多贡献者并行工作，并沿着一个主干合并他们的主题分支：不相关的合并出现在 `--full-history` 选项结果中。

当使用`--simplify-merges`选项时，提交的 `O` 和 `P` 从结果中消失。这是因为 `O` 和 `P` 重写的第二父本可以从它们的第一父本到达。这些边被移除，然后这些提交看起来就像与它们的父类一样的单亲提交。这也发生在提交 `N` 上，导致历史视图如下：

-----------------------------------------------------------------------
	  .-A---M--.
	 /     /    \
	I     B      R
	 \   /      /
	  \ /      /
	   `---X--'
-----------------------------------------------------------------------

在这个视图中，我们看到了所有来自`A`，`B`和`X`的重要单亲变化。我们还可以看到仔细解决的合并`M`和不那么仔细解决的合并`R`。这些信息通常足以确定为什么`A`和`B`的提交在默认视图中从历史中 "消失 "了。然而，这种方法也有一些问题。

第一个问题是性能。与之前的任何选项不同，`--simplify-merges` 选项需要在返回一个结果之前走完整个提交历史。这可能使该选项难以用于非常大的仓库。

第二个问题是审计的问题。当许多贡献者在同一个版本库中工作时，哪些合并提交将一个变化引入到一个重要的分支是很重要的。上面有问题的合并`R`不可能是用来合并到一个重要分支的合并提交。相反，`N'是用来将`R'和`X'合并到重要分支的。这个提交可能有关于为什么`X'会覆盖`A'和`B'的修改的信息，在其提交信息中。

--show-pulls::
	除了在默认历史中显示的提交之外，还要显示每一个与第一个父本不相同但与后来的父本相同的合并提交。
+
当一个合并提交被 `--show-pulls` 选项包含时，该合并被视为从另一个分支 “拉取” 来的修改。在这个例子中使用 `--show-pulls` 选项时（没有其他选项），得到的图是：
+
-----------------------------------------------------------------------
	I---X---R---N
-----------------------------------------------------------------------
+
这里，合并后的提交`R`和`N`被包括在内，因为它们分别将提交`X`和`R`拉到了基础分支。这些合并是`A`和`B`的提交没有出现在默认历史中的原因。
+
当 `--show-pulls` 与 `--simplify-merges` 选项配对时，该图包括所有必要的信息：
+
-----------------------------------------------------------------------
	  .-A---M--.   N
	 /     /    \ /
	I     B      R
	 \   /      /
	  \ /      /
	   `---X--'
-----------------------------------------------------------------------
+
请注意，由于`M`可以从`R`到达，从`N`到`M`的边被简化掉了。然而，`N`仍然作为一个重要的提交出现在历史中，因为它把`R`的修改 "拉 "进了主分支。

The `--simplify-by-decoration` option allows you to view only the big picture of the topology of the history, by omitting commits that are not referenced by tags. Commits are marked as !TREESAME (in other words, kept after history simplification rules described above) if (1) they are referenced by tags, or (2) they change the contents of the paths given on the command line. All other commits are marked as TREESAME (subject to be simplified away).

ifndef::git-shortlog[]
ifdef::git-rev-list[]
剖腹产助手
~~~~~

--bisect::
	将输出限制在一个提交对象上，该对象大致在包含和排除的提交之间。请注意，坏的分界参考`refs/bisect/bad`会被添加到包含的提交中（如果它存在的话），好的分界参考`refs/bisect/good-*`会被添加到排除的提交中（如果它们存在的话）。因此，假设`refs/bisect/`中没有参考文献，如果
+
-----------------------------------------------------------------------
	$ git rev-list --bisect foo ^bar ^baz
-----------------------------------------------------------------------
+
输出 'midpoint'，即两个命令的输出
+
-----------------------------------------------------------------------
	$ git rev-list foo ^midpoint
	$ git rev-list midpoint ^bar ^baz
-----------------------------------------------------------------------
+
would be of roughly the same length. Finding the change which introduces a regression is thus reduced to a binary search: repeatedly generate and test new 'midpoint's until the commit chain is of length one.

--bisect-vars::
	这与`--bisect`的计算方法相同，只是不使用`refs/bisect/`中的参考文献，而且输出的文本可以被shell评估。这几行将把中点修订的名称分配给变量`bisect_rev`，并把`bisect_rev`测试后的预期提交数分配给`bisect_nr`。如果`bisect_rev'结果是好的，预计测试的提交数量为`bisect_good'，如果`bisect_rev'结果是坏的，预计测试的提交数量为`bisect_bad'，以及我们现在正在分叉的提交数量为`bisect_all'。

--bisect-all::
	这将输出包含的提交和排除的提交之间的所有提交对象，按照它们与包含的提交和排除的提交的距离排序。`refs/bisect/`中的引用不被使用。离它们最远的会先显示出来。这也是 `--bisect` 选项唯一显示的对象。）
+
这很有用，因为当你因为某些原因想避免测试某些提交时（例如，它们可能无法编译），可以很容易地选择一个好的提交来测试。
+
这个选项可以和`--bisect-vars`一起使用，在这种情况下，在所有排序的提交对象之后，会有和`--bisect-vars`单独使用一样的文本。
endif::git-rev-list[]
endif::git-shortlog[]

ifndef::git-shortlog[]
承诺订购
~~~~

默认情况下，提交的内容是按时间顺序倒序显示的。

--date-order::
	在显示所有子代之前不显示父代，否则按提交时间戳顺序显示提交。

--author-date-order::
	在显示所有子代之前不显示父代，否则按作者时间戳顺序显示提交。

--topo-order::
	在显示所有子代之前不显示父代，并避免显示多行历史交错的提交。
+
例如，在这样的一个提交历史中：
+
----------------------------------------------------------------

    ---1----2----4----7
	\	       \
	 3----5----6----8---

----------------------------------------------------------------
+
其中数字表示提交时间戳的顺序，`git rev-list`和带有`--date-order`的朋友显示提交的时间戳顺序。8 7 6 5 4 3 2 1.
+
如果使用`--topo-order`，它们会显示8 6 5 3 7 4 2 1（或8 7 4 2 6 5 3 1）；一些较早的提交会显示在较新的提交之前，以避免显示两个平行开发轨道的提交混在一起。

--reverse::
	以相反的顺序输出选择显示的提交（见上面的提交限制部分）。不能与`--walk-reflogs`结合使用。
endif::git-shortlog[]

ifndef::git-shortlog[]
对象遍历
~~~~

这些选项主要是针对Git存储库的打包。

ifdef::git-rev-list[]
--objects::
	Print the object IDs of any object referenced by the listed commits. `--objects foo ^bar` thus means ``send me all object IDs which I need to download if I have the commit object _bar_ but not _foo_''. See also `--object-names` below.

--in-commit-order::
	按照提交的顺序打印树和blob的id。树和blob的id会在它们第一次被提交者引用后打印。

--objects-edge::
	Similar to `--objects`, but also print the IDs of excluded commits prefixed with a ``-'' character. This is used by linkgit:git-pack-objects[1] to build a ``thin'' pack, which records objects in deltified form based on objects contained in these excluded commits to reduce network traffic.

--objects-edge-aggressive::
	Similar to `--objects-edge`, but it tries harder to find excluded commits at the cost of increased time. This is used instead of `--objects-edge` to build ``thin'' packs for shallow repositories.

--indexed-objects::
	Pretend as if all trees and blobs used by the index are listed on the command line. Note that you probably want to use `--objects`, too.

--unpacked::
	只对 `---objects` 有用；打印不在包中的对象 ID。

--object-names::
	只对 `--objects` 有用；打印找到的对象ID的名称。这是默认的行为。注意，每个对象的 "名字" 是模糊的，主要是作为打包对象的提示。特别是：标签、树和二进制文件的名字不作区分；路径名称可以被修改以删除换行；如果一个对象会以不同的名字出现多次，则只显示一个名字。

--no-object-names::
	只对 `--objects` 有用；不打印找到的对象 ID 的名称。这与 `--object-names` 相反。这个标志允许输出更容易被 linkgit:git-cat-file[1] 等命令解析。

--filter=<过滤器定义>::
	Only useful with one of the `--objects*`; omits objects (usually blobs) from the list of printed objects. The '<filter-spec>' may be one of the following:
+
'--filter=blob:none'的形式可以省略所有的blob。
+
The form '--filter=blob:limit=<n>[kmg]' omits blobs of size at least n bytes or units. n may be zero. The suffixes k, m, and g can be used to name units in KiB, MiB, or GiB. For example, 'blob:limit=1k' is the same as 'blob:limit=1024'.
+
'--filter=object:type=(tag|commit|tree|blob)'的形式会省略所有不属于请求类型的对象。
+
表格 '--filter=sparse:oid=<blob-ish>' 使用 blob（或 blob 表达式）'<blob-ish>' 中包含的稀疏检出规范，以省略在请求的引用上进行稀疏检出时不需要的 blob。
+
'--filter=tree:<深度>' 的形式省略了所有从根树开始深度 >=<深度>（如果一个对象在所穿越的提交中位于多个深度，则为最小深度）的blobs和目录树。<深度>=0 将不包括任何目录树或 blobs，除非在命令行中明确包括（或使用 --stdin 选项时的标准输入）。<深度>=1 将只包括由 <提交> 或明确指定的对象所能到达的提交直接引用的目录树和 blobs。<深度>=2 与 <深度>=1 类似，同时也包括从明确给出的提交或目录树中移出的多一级的目录树和 blobs。
+
注意，出于安全原因，想要从文件系统上的任意路径读取的'--filter=sparse:path=<path>'形式已经被放弃了。
+
可以指定多个'--filter=' 标志来组合过滤器。只有那些被每个过滤器接受的对象才会被包括在内。
+
The form '--filter=combine:<filter1>+<filter2>+...<filterN>' can also be used to combined several filters, but this is harder than just repeating the '--filter' flag and is usually not necessary. Filters are joined by '{plus}' and individual filters are %-encoded (i.e. URL-encoded). Besides the '{plus}' and '%' characters, the following characters are reserved and also must be encoded: `~!@#$^&*()[]{}\;",<>?`+&#39;&#96;+ as well as all characters with ASCII code &lt;= `0x20`, which includes space and newline.
+
其他任意的字符也可以被编码。例如，'combined:tree:3+blob:none'和'combined:tree%3A3+blob%3Anone'是等同的。

--no-filter::
	关掉之前的任何`--filter=`参数。

--filter-provided-objects::
	过滤明确提供的对象的列表，否则，即使它们不符合任何过滤器，也会被打印出来。只对`--filter=`有用。

--filter-print-omitted::
	Only useful with `--filter=`; prints a list of the objects omitted by the filter. Object IDs are prefixed with a ``~'' character.

--missing=<缺失行为>::
	A debug option to help with future "partial clone" development. This option specifies how missing objects are handled.
+
The form '--missing=error' requests that rev-list stop with an error if a missing object is encountered. This is the default action.
+
The form '--missing=allow-any' will allow object traversal to continue if a missing object is encountered. Missing objects will silently be omitted from the results.
+
The form '--missing=allow-promisor' is like 'allow-any', but will only allow object traversal to continue for EXPECTED promisor missing objects. Unexpected missing objects will raise an error.
+
The form '--missing=print' is like 'allow-any', but will also print a list of the missing objects. Object IDs are prefixed with a ``?'' character.

--exclude-promisor-objects::
	(For internal use only.) Prefilter object traversal at promisor boundary. This is used with partial clone. This is stronger than `--missing=allow-promisor` because it limits the traversal, rather than just silencing errors about missing objects.
endif::git-rev-list[]

--no-walk[=(sorted|unsorted)]::
	Only show the given commits, but do not traverse their ancestors. This has no effect if a range is specified. If the argument `unsorted` is given, the commits are shown in the order they were given on the command line. Otherwise (if `sorted` or no argument was given), the commits are shown in reverse chronological order by commit time. Cannot be combined with `--graph`.

--do-walk::
	覆盖之前的 `--no-walk` 。
endif::git-shortlog[]

ifndef::git-shortlog[]
承诺格式化
~~~~~

ifdef::git-rev-list[]
使用这些选项，linkgit:git-rev-list[1] 的作用类似于更专业的提交日志工具系列：linkgit:git-log[1]，linkgit:git-show[1]，和linkgit:git-whatchanged[1]
endif::git-rev-list[]

--pretty[=<format>]::
--format=<format>::

	以指定的格式打印提交日志的内容，其中'<format>'可以是'oneline'、'short'、'medium'、'full'、'fuller'、'reference'、'email'、'raw'、'format:<string>'和'tformat:<string>'之一。 当'<format>'不是上述任何一种，并且其中有'%placeholder'时，它的作用就像给出'--pretty=tformat:<format>'一样。
+
参见 "PRETTY FORMATS "部分，了解每种格式的一些额外细节。 当'=<格式>'部分被省略时，它默认为'中等'。
+
注意：你可以在版本库配置中指定默认的漂亮格式（见linkgit:git-config[1]）。

--abbrev-commit::
	不要显示完整的40字节的十六进制提交对象名称，而是显示一个前缀，以唯一的方式命名该对象。 "--abbrev=<n>"选项可以用来指定前缀的最小长度（如果显示的话，它也会修改diff输出）。
+
这应该使"--pretty=oneline "对于使用80列终端的人来说更容易阅读。

--no-abbrev-commit::
	显示完整的40字节十六进制的提交对象名称。这否定了`--abbrev-commit`，无论是明确的还是由其他选项如"--oneline "暗示的。它还覆盖了`log.abbrevCommit`变量。

--oneline::
	这是"--pretty=oneline --abbrev-commit "的简写，一起使用。

--encoding=<encoding>::
	提交对象在其编码头中记录了日志信息所使用的编码；这个选项可以用来告诉命令以用户喜欢的编码来重新编码提交日志信息。 对于非管道命令，默认为UTF-8。请注意，如果一个对象声称是以`X`编码的，而我们是以`X`输出的，我们将逐字输出该对象；这意味着原始提交中的无效序列可能会被复制到输出中。

--expand-tabs=<n>::
--expand-tabs::
--no-expand-tabs::
	在输出中显示之前，在日志信息中进行标签扩展（用足够的空格替换每个标签，以填充到下一个显示列的'<n>'的倍数）。 `--expand-tabs`是`--expand-tabs=8`的简写，`--no-expand-tabs`是`--expand-tabs=0`的简写，它禁止标签扩展。
+
默认情况下，标签会以漂亮的格式展开，将日志信息缩进4个空格（即 "中"，这是默认的，"全"，和 "更全"）。

ifndef::git-rev-list[]
--notes[=<ref>]::
	在显示提交日志信息时，显示注释提交的说明（见linkgit:git-notes[1]）。 这是`git log`、`git show`和`git whatchanged`命令的默认设置，当命令行中没有给出`--pretty`、`--format`或`--oneline`选项时。
+
默认情况下，显示的注释来自于`core.notesRef`和`notes.displayRef`变量（或相应的环境覆盖）中列出的注释参考。更多细节见linkgit:git-config[1]。
+
有了一个可选的'<ref>'参数，就可以使用ref来寻找要显示的笔记。 当ref以`refs/notes/`开头时，可以指定完整的ref名称；当它以`notes/`开头时，`refs/`，否则`refs/notes/`前缀，形成ref的全名。
+
多个--音符选项可以组合起来，控制哪些音符被显示。例如。"--notes=foo "将只显示来自 "refs/notes/foo "的注释；"--notes=foo --notes "将同时显示来自 "refs/notes/foo "和默认注释的注释。

--no-notes::
	不显示注释。这否定了上面的`--notes`选项，因为它重新设置了显示注释的注释列表。 选项按照命令行给出的顺序进行解析，因此，例如"--notes --notes=foo --no-notes --notes=bar "将只显示来自 "refs/notes/bar "的注释。

--show-notes[=<ref>]::
--[no-]standard-notes::
	这些选项已被废弃。请使用上面的 --notes/-no-notes 选项来代替。
endif::git-rev-list[]

--show-signature::
	通过将签名传递给 `gpg --verify` 来检查已签名的提交对象的有效性，并显示输出。
[]

--relative-date::
	`--date=relative`的同义词。

--date=<格式>::
	只对以人类可读格式显示的日期生效，例如使用`--pretty`时。`log.date`配置变量为日志命令的`--date`选项设置默认值。默认情况下，日期显示在原始时区（提交者或作者的时区）。如果`-local`被附加到格式中（例如，`iso-local`），就会使用用户的本地时区。
+
--
`--date=relative`显示相对于当前时间的日期，例如：`2小时前''。`--local`选项对`--date=relative`没有影响。

`--date=local`是`--date=default-local`的一个别名。

`--date=iso` (or `--date=iso8601`) shows timestamps in a ISO 8601-like format. The differences to the strict ISO 8601 format are:

	- 用空格代替`T`日期/时间分隔符
	- 时间和时区之间的空间
	- 时区的小时和分钟之间没有冒号

`--date=iso-strict`（或`--date=iso8601-strict`）显示严格的ISO 8601格式的时间戳。

`--date=rfc`（或`--date=rfc2822`）显示RFC 2822格式的时间戳，经常出现在电子邮件中。

`--date=short`只显示日期，而不是时间，格式为`YYYY-MM-DD`。

`--date=raw` shows the date as seconds since the epoch (1970-01-01 00:00:00 UTC), followed by a space, and then the timezone as an offset from UTC (a `+` or `-` with four digits; the first two are hours, and the second two are minutes). I.e., as if the timestamp were formatted with `strftime("%s %z")`). Note that the `-local` option does not affect the seconds-since-epoch value (which is always measured in UTC), but does switch the accompanying timezone value.

`--date=human` shows the timezone if the timezone does not match the current time-zone, and doesn't print the whole date if that matches (ie skip printing year for dates that are "this year", but also skip the whole date itself if it's in the last few days and we can just say what weekday it was). For older dates the hour and minute is also omitted.

`--date=unix` shows the date as a Unix epoch timestamp (seconds since 1970). As with `--raw`, this is always in UTC and therefore `-local` has no effect.

`--date=format:...` feeds the format `...` to your system `strftime`, except for %s, %z, and %Z, which are handled internally. Use `--date=format:%c` to show the date in your system locale's preferred format. See the `strftime` manual for a complete list of format placeholders. When using `-local`, the correct syntax is `--date=format-local:...`.

`--date=default` is the default format, and is based on ctime(3) output. It shows a single line with three-letter day of the week, three-letter month, day-of-month, hour-minute-seconds in "HH:MM:SS" format, followed by 4-digit year, plus timezone information, unless the local time zone is used, e.g. `Thu Jan 1 00:00:00 1970 +0000`.
--

ifdef::git-rev-list[]
--header::
	以原始格式打印提交的内容；每条记录用NUL字符分隔。

--no-commit-header::
	Suppress the header line containing "commit" and the object ID printed before the specified format. This has no effect on the built-in formats; only custom formats are affected.

--commit-header::
	覆盖之前的 `--no-commit-header` 选项。
endif::git-rev-list[]

--parents::
	Print also the parents of the commit (in the form "commit parent..."). Also enables parent rewriting, see 'History Simplification' above.

--children::
	Print also the children of the commit (in the form "commit child..."). Also enables parent rewriting, see 'History Simplification' above.

ifdef::git-rev-list[]
--timestamp::
	打印原始提交时间戳。
endif::git-rev-list[]

--left-right::
	Mark which side of a symmetric difference a commit is reachable from. Commits from the left side are prefixed with `<` and those from the right with `>`. If combined with `--boundary`, those commits are prefixed with `-`.
+
例如，如果你有这样的拓扑结构：
+
-----------------------------------------------------------------------
	     y---b---b  branch B
	    / \ /
	   /   .
	  /   / \
	 o---x---a---a  branch A
-----------------------------------------------------------------------
+
你会得到这样的输出：
+
-----------------------------------------------------------------------
	$ git rev-list --left-right --boundary --pretty=oneline A...B

	>bbbbbbb... 3rd on b
	>bbbbbbb... 2nd on b
	<aaaaaaa... 3rd on a
	<aaaaaaa... 2nd on a
	-yyyyyyy... 1st on b
	-xxxxxxx... 1st on a
-----------------------------------------------------------------------

--graph::
	Draw a text-based graphical representation of the commit history on the left hand side of the output. This may cause extra lines to be printed in between commits, in order for the graph history to be drawn properly. Cannot be combined with `--no-walk`.
+
这可以使父代改写，见上面的'历史简化'。
+
这意味着默认情况下是`--topo-order`选项，但也可以指定`--date-order`选项。

--show-linear-break[=<阻隔>]::
	如果不使用 --graph，所有的历史分支都会被压扁，这就很难看出两个连续的提交并不属于一个线性分支。在这种情况下，该选项会在它们之间设置一个障碍。如果指定了"<barrier>"，就会显示这个字符串，而不是默认的。

ifdef::git-rev-list[]
--count::
	Print a number stating how many commits would have been listed, and suppress all other output. When used together with `--left-right`, instead print the counts for left and right commits, separated by a tab. When used together with `--cherry-mark`, omit patch equivalent commits from these counts and print the count for equivalent commits separated by a tab.
endif::git-rev-list[]
endif::git-shortlog[]
[]

漂亮的格式
-----

If the commit is a merge, and if the pretty-format is not 'oneline', 'email' or 'raw', an additional line is inserted before the 'Author:' line. This line begins with "Merge: " and the hashes of ancestral commits are printed, separated by spaces. Note that the listed commits may not necessarily be the list of the *direct* parent commits if you have limited your view of history: for example, if you are only interested in changes related to a certain directory or file.

有几种内置的格式，你可以通过将 pretty.<名称> 配置选项设置为另一种格式名称或 'format:' 字符串来定义额外的格式，如下所述（见 linkgit:git-config[1] ）。下面是内置格式的细节：

* 'oneline'

	  <哈希值> <标题行>
+
这个设计是为了尽可能的紧凑。

* 'short'

	  承诺<hash>
	  作者。<作者>的情况

	      <标题行>

* 'medium'

	  commit <哈希值>
	  Author: <作者>
	  Date:   <提交日期>

	      <标题行>

	      <完整的提交信息

* 'full'

	  承诺<hash>
	  作者。< Author>
	  承诺。<committer>（提交者）。

	      <标题行>

	      <完整的提交信息

* 'fuller'

	  commit <哈希值>
	  Author:     <作者>
	  AuthorDate: <作者提交日期>
	  Commit:     <提交者>
	  CommitDate: <提交者提交日期>

	       <标题行>

	       <完整的提交信息

* ‘引用’

	  <缩写哈希值>（<标题行>，<简短的作者日期>）
+
This format is used to refer to another commit in a commit message and is the same as `--pretty='format:%C(auto)%h (%s, %ad)'`. By default, the date is formatted with `--date=short` unless another `--date` option is explicitly specified. As with any `format:` with format placeholders, its output is not affected by other options like `--decorate` and `--walk-reflogs`.

* 'email'

	  From <哈希> <日期>
	  From: <作者>
	  Date: <作者提交日期>
	  Subject: [PATCH] <标题行>

	  <完整的提交信息

* 'mboxrd'
+
和 "email "一样，但提交信息中以 "From "开头的行（前面有零个或多个">"）用">"引出，这样就不会被混淆为开始了一个新的提交。

* 'raw'
+
The 'raw' format shows the entire commit exactly as stored in the commit object. Notably, the hashes are displayed in full, regardless of whether --abbrev or --no-abbrev are used, and 'parents' information show the true parent commits, without taking grafts or history simplification into account. Note that this format affects the way commits are displayed, but not the way the diff is shown e.g. with `git log --raw`. To get full object names in a raw diff format, use `--no-abbrev`.

* 'format:<格式字符串>'
+
'format:<格式字符串' 格式允许你指定要显示的信息。它的工作原理有点像 printf 格式，但有一个明显的例外，那就是换行符是 '%n' 而不是 '\n'。
+
例如，'format: "The author of %h was %an, %ar%nThe title was >>%s<<%n"' 会显示这样的内容：
+
-------
fe6e0ee的作者是Junio C Hamano, 23小时前
标题是 >>t4119: 测试传统diff输入的自动计算-p<n>。

-------
+
占位符是：

- 占位符，可扩展为一个字面字符：
'%n':: 换行
'%%':: 一个原始的'%'
'%x00':: '%x' 后跟两个十六进制数字，会被一个包含十六进制数字值的字节替换（在本文档的其余部分，我们称之为 “字面格式化代码”）。

- 影响后面占位符的格式化的占位符：
'%Cred':: 切换颜色为红色
'%Cgreen':: 切换颜色为绿色
'%Cblue':: 将颜色改为蓝色
'%Creset':: 重置颜色
'%C(...)':: color specification, as described under Values in the "CONFIGURATION FILE" section of linkgit:git-config[1]. By default, colors are shown only when enabled for log output (by `color.diff`, `color.ui`, or `--color`, and respecting the `auto` settings of the former if we are going to a terminal). `%C(auto,...)` is accepted as a historical synonym for the default (e.g., `%C(auto,red)`). Specifying `%C(always,...)` will show the colors even when color is not otherwise enabled (though consider just using `--color=always` to enable color for the whole output, including this format and anything else git might color). `auto` alone (i.e. `%C(auto)`) will turn on auto coloring on the next placeholders until the color is switched again.
'%m':: 左（`<`）、右（`>`）或边界（`-`）标记
'%w([<w>[,<i1>[,<i2>]]])':: 开关包行，就像 linkgit:git-shortlog[1] 的 -w 选项。
'%<(<N>[,trunc|ltrunc|mtrunc])':: make the next placeholder take at least N column widths, padding spaces on the right if necessary. Optionally truncate (with ellipsis '..') at the left (ltrunc) `..ft`, the middle (mtrunc) `mi..le`, or the end (trunc) `rig..`, if the output is longer than N columns. Note 1: that truncating only works correctly with N >= 2. Note 2: spaces around the N and M (see below) values are optional. Note 3: Emojis and other wide characters will take two display columns, which may over-run column boundaries. Note 4: decomposed character combining marks may be misplaced at padding boundaries.
'%<|(<M>)':: make the next placeholder take at least until Mth display column, padding spaces on the right if necessary. Use negative M values for column positions measured from the right hand edge of the terminal window.
'%>(<N>)', '%>|(<M>)':: 分别类似于 '%<( <N> )' 、'%<|( <M> )'，但在左侧填充空格
'%>>(<N>)', '%>>|(<M>)':: 分别类似于'%>(<N>)'、'%>|(<M>)'，只是如果下一个占位符占用的空间比给定的多，并且其左侧有空格，则使用这些空格
'%><(<N>)', '%><|(<M>)':: 分别类似于'%<( <N> )' 和 '%<|( <M> )'，但两边都有填充（即文本居中）

- 占位符，扩展到从提交中提取的信息：
'%H':: 提交的哈希值
'%h':: 简称提交哈希
'%T':: 目录树哈希值
'%t':: 简称树形哈希
'%P':: 父类哈希值
'%p':: 缩写的父母哈希值
'%an':: 作者名
'%aN':: 作者名（关于 .mailmap，请参见 linkgit:git-shortlog[1] 或 linkgit:git-blame[1]
'%ae':: 作者电子邮箱
'%aE':: 作者电子邮件（关于 .mailmap，请参见 linkgit:git-shortlog[1] 或 linkgit:git-blame[1]
'%al':: 作者电子邮件的本地部分（'@' 符号之前的部分）
'%aL':: 尊重 .mailmap 作者的本地部分（参见 '%al' ），参见 linkgit:git-shortlog[1] 或 linkgit:git-blame[1])
'%ad':: 作者日期（格式尊重--date=选项
'%aD':: 作者日期，RFC2822风格
'%ar':: 作者日期，相对
'%at':: 作者日期，UNIX时间戳
'%ai':: 作者日期，类似ISO 8601的格式
'%aI':: 作者日期，严格的ISO 8601格式
'%as':: 作者日期，短格式（ `YYYY-MM-DD` ）
'%ah':: 作者日期，以易读形式呈现（就像 linkgit:git-rev-list[1] 的 `--date=human` 选项）
'%cn':: 提交者名称
'%cN':: 提交者名称（尊重 .mailmap，参见 linkgit:git-shortlog[1] 或 linkgit:git-blame[1]
'%ce':: 提交者电子邮箱
'%cE':: 提交者电子邮箱（尊重 .mailmap，参见 linkgit:git-shortlog[1] 或 linkgit:git-blame[1]
'%cl':: 提交者电子邮件的本地部分（'@' 符号之前的部分）
'%cL':: 提交者本地部分（参见'%cl' ）尊重 .mailmap, 参见 linkgit:git-shortlog[1] 或 linkgit:git-blame[1])
'%cd':: 承诺人日期（格式尊重--date=选项
'%cD':: 承诺人日期，RFC2822风格
'%cr':: 承诺人日期，相对
'%ct':: 提交者日期，UNIX时间戳
'%ci':: 承诺人日期，类似ISO 8601的格式
'%cI':: 承诺人日期，严格的ISO 8601格式
'%cs':: 承诺人日期，短格式（ `YYYY-MM-DD` ）
'%ch':: 提交者的日期，人类风格（就像 linkgit:git-rev-list[1] 的 `--date=human` 选项）
'%d':: ref名称，就像linkgit:git-log[1]的--decorate选项。
'%D':: 没有"（"、"）"包装的参考文献名称。
'%(decorate[:<选项>])'::
自定义装饰的引用名称。`decorate` 字符串后面可以是冒号和零个或多个以逗号分隔的选项。选项值可能包含字面格式化代码。由于逗号（`%x2C`）和结尾括号（`%x29`）在选项语法中的作用，因此必须使用这些代码。
+
** 'prefix=<value>': Shown before the list of ref names. Defaults to "{nbsp}`(`".
** 'suffix=<value>': Shown after the list of ref names. Defaults to "`)`".
** 'separator=<value>': Shown between ref names. Defaults to "`,`{nbsp}".
** 'point=<值>'： 显示在 HEAD 和其指向的分支（如果有）之间。
		      默认为 "{nbsp}`->`{nbsp}"。
** 'tag=<值>'： 显示在标记名称之前。默认为 "`tag:`{nbsp}"。

+
例如，制作不带包装或标签注释的装饰，并用空格作为分隔符：
+
`%(decorate:prefix=,suffix=,tag=,separator= )`

'%(describe[:<选项>])'::
human-readable name, like linkgit:git-describe[1]; empty string for undescribable commits. The `describe` string may be followed by a colon and zero or more comma-separated options. Descriptions can be inconsistent when tags are added or removed at the same time.
+
** 'tags[=<bool-value>]'：不仅考虑带注释的标签，还考虑轻量级标签。
** 'abbrev=<数量>'：不使用缩写对象名称的默认十六进制位数（根据仓库中对象的数量而变化，默认为 7 位），而是使用 <数量> 的位数，或根据需要的位数来组成唯一的对象名称。
** 'match=<pattern>':只考虑与给定的`glob(7)`模式匹配的标签，不包括 "refs/tags/"前缀。
** 'exclude=<pattern>':不考虑匹配给定`glob(7)`模式的标签，排除 "refs/tags/"前缀。

'%S':: 在命令行中给出的提交名称（如 `git log --source`），只对 `git log` 起作用
'%e':: 编码方式
'%s':: 主题
'%f':: 经过消毒的主题行，适合于文件名
'%b':: 正文
'%B':: 原始体（未包装的主题和体）
ifndef::git-rev-list[]
'%N':: 承诺说明
endif::git-rev-list[]
'%GG':: 来自GPG的签名提交的原始验证信息
'%G?':: show "G" for a good (valid) signature, "B" for a bad signature, "U" for a good signature with unknown validity, "X" for a good signature that has expired, "Y" for a good signature made by an expired key, "R" for a good signature made by a revoked key, "E" if the signature cannot be checked (e.g. missing key) and "N" for no signature
'%GS':: 显示已签名的提交的签名者的名字
'%GK':: 显示用于签署已签名的承诺的密钥
'%GF':: 显示用于签署已签名提交文件的密钥的指纹
'%GP':: 显示主键的指纹，该主键的子键被用来签署一个已签署的提交
'%GT':: 显示用于签署已签名的承诺的密钥的信任级别
'%gD':: reflog选择器，例如，`refs/stash@{1}`或`refs/stash@{2分钟前}`；其格式遵循`-g`选项的规则。`@'前面的部分是命令行上给出的参考文献名称（所以`git log -g refs/heads/master`会产生`refs/heads/master@{0}`）。
'%gd':: 简化的 reflog 选择器；与 `%gD` 相同，但 refname 部分被缩短以利于人类阅读（因此 `refs/heads/master` 变成了 `master`）。
'%gn':: 记录身份名称
'%gN':: 引用日志身份名称（尊重 .mailmap，参见 linkgit:git-shortlog[1] 或 linkgit:git-blame[1]
'%ge':: 重新记录身份邮件
'%gE':: 引用日志身份电子邮箱（尊重 .mailmap，参见 linkgit:git-shortlog[1] 或 linkgit:git-blame[1]
'%gs':: 记录主题
'%(trailers[:<选项>])'::
显示由 linkgit:git-interpret-trailers[1] 解释的正文的为主。`trailers` 字符串后面可以有冒号和零个或多个逗号分隔的选项。 如果任何选项被多次提供，则最后出现的选项获胜。
+
** 'key=<key>': only show trailers with specified <key>. Matching is done case-insensitively and trailing colon is optional. If option is given multiple times trailer lines matching any of the keys are shown. This option automatically enables the `only` option so that non-trailer lines in the trailer block are hidden. If that is not desired it can be disabled with `only=false`. E.g., `%(trailers:key=Reviewed-by)` shows trailer lines with key `Reviewed-by`.
** 'only[=<布尔值>]' ：选择是否应该包括来自尾注块的非尾注行。
** 'separator=<切片>'：指定插入在尾注行之间的分隔符。如果不使用该选项，则每行以换行符结束。字符串 <切片> 可以包含上述字面格式化代码。要使用逗号作为分隔符，必须使用 `%x2C`，否则会被解析为下一个选项。例如，`%(trailer:key=Ticket,separator=%x2C )` 显示所有关键字为 "Ticket" 的尾注行，并用逗号和空格分隔。
** 'unfold[=<布尔值>]'：使它的行为就像 interpret-trailer 的 `--unfold` 选项被给出一样。例如，`%(trailers:only,unfold=true)`会展开并显示所有的尾注行。
** 'keyonly[=<布尔值>]'：只显示尾注的关键部分。
** 'valueonly[=<布尔值>]'：只显示尾注的值部分。
** 'key_value_separator=<切片>'：指定在尾注行之间插入一个分隔符。当这个选项没有给出时，每个尾注的键值对都用 ": " 分开。 否则，它的语义与上面的 'separator=<切片>' 相同。

NOTE: 一些占位符可能取决于给修订版遍历引擎的其他选项。例如，`%g*` reflog选项将插入一个空字符串，除非我们正在遍历reflog条目（例如，通过`git log -g`）。`%d`和`%D`占位符将使用 "短 "装饰格式，如果`--decorate`没有在命令行上提供。

布尔选项接受一个可选的值`[=<布尔值>]`。`true`, `false`, `on`, `off`等值都可以接受。参见linkgit:git-config[1]中 “示例” 的 “布尔” 子章节。如果一个布尔选项没有给出值，它就被启用。

如果你在占位符的'%'后面加了一个`+'（加号），当且仅当占位符扩展为一个非空字符串时，在扩展前会立即插入换行符。

如果你在占位符的'%'后面加了一个`-'（减号），如果且仅当占位符扩展为空字符串时，紧接着扩展前的所有连续换行将被删除。

如果你在占位符的'%'后面加了一个``（空格），当且仅当占位符扩展到一个非空字符串时，空格就会紧接着插入扩展。

* 't格式:'
+
The 'tformat:' format works exactly like 'format:', except that it provides "terminator" semantics instead of "separator" semantics. In other words, each commit has the message terminator character (usually a newline) appended, rather than a separator placed between entries. This means that the final entry of a single-line format will be properly terminated with a new line, just as the "oneline" format does. For example:
+
---------------------
$ git log -2 --pretty=format:%h 4da45bef \
  | perl -pe '$_ .= " -- NO NEWLINE\n" unless /\n/'
4da45be
7134973 -- NO NEWLINE

$ git log -2 --pretty=tformat:%h 4da45bef \
  | perl -pe '$_ .= " -- NO NEWLINE\n" unless /\n/'
4da45be
7134973
---------------------
+
In addition, any unrecognized string that has a `%` in it is interpreted as if it has `tformat:` in front of it. For example, these two are equivalent:
+
---------------------
$ git log -2 --pretty=tformat:%h 4da45bef
$ git log -2 --pretty=%h 4da45bef
---------------------
[]

差异格式化
-----

默认情况下，`git log`不会产生任何差异输出。下面的选项可以用来显示每次提交所做的修改。

请注意，除非明确给出了 `--diff-merges` 变体（包括短 `-m`、`-c`、`--cc` 和 `--dd` 选项），否则合并提交不会显示差异，即使选择了 `--patch` 等差异格式，也不会匹配 `-S` 等搜索选项。使用 `--first-parent` 时例外，在这种情况下，`--first-parent` 是合并提交的默认格式。

:git-log: 1
:diff-merges-default: `off`
// Please don't remove this comment as asciidoc behaves badly when
// the first non-empty line is ifdef/ifndef. The symptom is that
// without this comment the <git-diff-core> attribute conditionally
// defined below ends up being defined unconditionally.
// Last checked with asciidoc 7.0.2.

ifndef::git-format-patch[]
ifndef::git-diff[]
ifndef::git-log[]
:git-diff-core: 1
endif::git-log[]
endif::git-diff[]
endif::git-format-patch[]

ifdef::git-format-patch[]
-p::
--no-stat::
	生成没有任何差异状态(diffstats)的普通补丁。
endif::git-format-patch[]

ifndef::git-format-patch[]
-p::
-u::
--patch::
	生成补丁（请参阅 <<generate_patch_text_with_p>> ）。
ifdef::git-diff[]
	这是默认设置。
endif::git-diff[]

-s::
--no-patch::
	Suppress all output from the diff machinery. Useful for commands like `git show` that show the patch by default to squelch their output, or to cancel the effect of options like `--patch`, `--stat` earlier on the command line in an alias.

endif::git-format-patch[]

ifdef::git-log[]
-m::
	以默认格式显示合并提交的差异。这与 '--diff-merges=on' 类似，但除非同时给出 `-p`，否则 `-m` 不会产生任何输出。

-c::
	Produce combined diff output for merge commits. Shortcut for '--diff-merges=combined -p'.

--cc::
	Produce dense combined diff output for merge commits. Shortcut for '--diff-merges=dense-combined -p'.

--dd::
	Produce diff with respect to first parent for both merge and regular commits. Shortcut for '--diff-merges=first-parent -p'.

--remerge-diff::
	Produce remerge-diff output for merge commits. Shortcut for '--diff-merges=remerge -p'.

--no-diff-merges::
	'--diff-merges=off' 的同义词。

--diff-merges=<格式>::
	指定合并提交时使用的差异格式。默认为 {diff-merges-default}，但当使用 `--first-parent` 选项时，默认为 `first-parent`。
+
支持以下格式：
+
--
off, none::
	禁用合并提交时的差异输出。对覆盖隐含值很有用。
+
on, m::
	该选项使合并提交的差异输出以默认格式显示。`-m` 只有在 `-p` 的情况下才会产生输出。默认格式可以通过 `log.diffMerges` 配置参数改变，默认值为 `separate` 。
+
first-parent, 1::
	显示与第一个父提交的完整差异。这与 `--patch` 为非合并提交生成的格式相同。
+
separate::
	Show full diff with respect to each of parents. Separate log entry and diff is generated for each parent.
+
combined, c::
	同时显示每个父文件与合并结果之间的差异，而不是逐个显示父文件与合并结果之间的成对差异。此外，它只列出从所有父文件修改过的文件。
+
dense-combined, cc::
	使用该选项，通过省略不感兴趣的块，进一步压缩 `--diff-merges=combined` 产生的输出，这类块在父提交中的内容只有两个变体，并且合并结果选择了其中一个而没有修改。 `--cc` 选项暗含 `-p`。
+
remerge, r::
	Remerge two-parent merge commits to create a temporary tree object--potentially containing files with conflict markers and such. A diff is then shown between that temporary tree and the actual merge commit.
+
使用该选项时发出的输出是可以改变的，它与其他选项的互动也是可以改变的（除非有明确的记录）。
--

--combined-all-paths::
	This flag causes combined diffs (used for merge commits) to list the name of the file from all parents. It thus only has effect when `--diff-merges=[dense-]combined` is in use, and is likely only useful if filename changes are detected (i.e. when either rename or copy detection have been requested).
endif::git-log[]

-U<n>::
--unified=<n>::
	生成带有 <n> 行上下文的差异，而不是通常的 3 行。暗含 `--patch` 选项。
ifndef::git-format-patch[]
	暗含 `--patch` 选项。
endif::git-format-patch[]

--output=<文件>::
	输出到一个特定的文件，而不是标准输出。

--output-indicator-new=<字符>::
--output-indicator-old=<字符>::
--output-indicator-context=<字符>::
	指定在生成的补丁中用来表示新、旧或上下文行的字符。通常它们分别是 '+'、'-' 和 ' '（空格）。

ifndef::git-format-patch[]
--raw::
ifndef::git-log[]
	生成原始格式的差异。
ifdef::git-diff-core[]
	这是默认设置。
endif::git-diff-core[]
endif::git-log[]
ifdef::git-log[]
	对于每一个提交，使用原始的差异格式
	请参见 linkgit:git-diff[1] 中
	“原始输出格式” 一节 。
	这与显示日志中的本身的原始格式不同
	你可以用 `--format=raw` 来实现。
endif::git-log[]
endif::git-format-patch[]

ifndef::git-format-patch[]
--patch-with-raw::
	`-p--raw` 的同义词。
endif::git-format-patch[]

ifdef::git-log[]
-t::
	在差异输出中显示目录树对象。
endif::git-log[]

--indent-heuristic::
	启用启发式的缩进区块的方法，使得补丁更易读。这是默认选项。

--no-indent-heuristic::
	禁用启发式缩进。

--minimal::
	花费额外的时间以确保生成尽可能小的差异。

--patience::
	使用 "patience diff" 算法生成差异。

--histogram::
	使用 "histogram diff" 算法生成差异。

--anchored=<文本>::
	使用 "anchored diff" 算法生成差异。
+
这个选项可以被指定多次。
+
如果某一个行同时存在于来源和目标中，各只出现一次，以这个文本开头，这个算法试图防止它在输出中以删除或添加的形式出现。它在内部使用了 "patience diff" 算法。

--diff-algorithm={patience|minimal|histogram|myers}::
	选择差异算法。有如下可选项：
+
--
`default`, `myers`;;
	基本的贪婪差异算法。当前是默认设置。
`minimal`;;
	花费额外的时间以确保生成尽可能小的差异。
`patience`;;
	使用 "patience diff" 算法时产生的补丁。
`histogram`;;
	该算法将耐心算法扩展为 “支持低发生率的常见元素”。
--
+
例如，如果你将 `diff.algorithm` 变量配置为非默认值，但希望使用默认值，那么你必须使用 `--diff-algorithm=default` 选项。

--stat[=<宽度>[,<名称宽度>[,<数值>]]]::
	Generate a diffstat. By default, as much space as necessary will be used for the filename part, and the rest for the graph part. Maximum width defaults to terminal width, or 80 columns if not connected to a terminal, and can be overridden by `<width>`. The width of the filename part can be limited by giving another width `<name-width>` after a comma or by setting `diff.statNameWidth=<width>`. The width of the graph part can be limited by using `--stat-graph-width=<width>` or by setting `diff.statGraphWidth=<width>`. Using `--stat` or `--stat-graph-width` affects all commands generating a stat graph, while setting `diff.statNameWidth` or `diff.statGraphWidth` does not affect `git format-patch`. By giving a third parameter `<count>`, you can limit the output to the first `<count>` lines, followed by `...` if there are more.
+
这些参数也可以用 `--stat-width=<宽度>`，`--stat-name-width=<名称宽度>` 和 `--stat-count=<数量>` 单独设置。

--compact-summary::
	在差异状态中输出扩展头信息的压缩摘要，如文件的创建或删除（"new" 或 "good"。如果是符号链接，则为 "+l"）和模式变化（"+x" 或 "-x" 分别用于添加或删除可执行位）。这些信息被放在文件名部分和图形部分之间。暗含 `--stat` 选项。

--numstat::
	Similar to `--stat`, but shows number of added and deleted lines in decimal notation and pathname without abbreviation, to make it more machine friendly. For binary files, outputs two `-` instead of saying `0 0`.

--shortstat::
	只输出使用 `--stat` 选项输出的最后一行，包含修改的文件总数，添加和删除的行数。

-X[<参数1,参数2,...>]::
--dirstat[=<参数1,参数2,...>]::
	Output the distribution of relative amount of changes for each sub-directory. The behavior of `--dirstat` can be customized by passing it a comma separated list of parameters. The defaults are controlled by the `diff.dirstat` configuration variable (see linkgit:git-config[1]). The following parameters are available:
+
--
`changes`;;
	Compute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file. In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given.
`lines`;;
	通过做常规基于行的差异分析，计算分布状态的数字，并将删除/添加的行数相加。(对于二进制文件，用 64 字节的块来计算，因为二进制文件没有行的概念)。在使用 `--dirstat` 时这个选项的行为开销比 `changes` 更大，但会对文件中重新排列的行进行计数。其得到的输出结果与其他的 `--*stat` 选项一致。
`files`;;
	Compute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest `--dirstat` behavior, since it does not have to look at the file contents at all.
`cumulative`;;
	Count changes in a child directory for the parent directory as well. Note that when using `cumulative`, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the `noncumulative` parameter.
<limit>;;
	An integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output.
--
+
例如：下面的参数会统计更改的文件，同时忽略占更改文件总数 10% 以下的目录，并累积父目录中的子目录计数：`--dirstat=files,10,cumulative`。

--cumulative::
	--dirstat=cumulative 同义

--dirstat-by-file[=<参数1,参数2>...]::
	Synonym for --dirstat=files,<param1>,<param2>...

--summary::
	输出扩展头信息，如创建、重命名和模式变化等，的压缩摘要。

ifndef::git-format-patch[]
--patch-with-stat::
	同义词 '-p --stat'。
endif::git-format-patch[]

ifndef::git-format-patch[]

-z::
ifdef::git-log[]
	用 NUL 而不是用换行来分隔提交。
+
另外，当给出 `--raw` 或 `--numstat` 时，不合并路径名，并使用 NUL 作为输出字段终止符。
endif::git-log[]
ifndef::git-log[]
	另外，当给出 `--raw`、`--numstat`、 `--name-only` 或 `--name-status` 选项时，
	不合并路径名，并使用 NUL 作为输出字段终止符。
endif::git-log[]
+
如果没有这个选项，带 “不常见” 字符的路径名会被引用，正如配置变量 `core.quotePath` 所解释的那样（参见 linkgit:git-config[1]）。

--name-only::
	Show only names of changed files. The file names are often encoded in UTF-8. For more information see the discussion about encoding in the linkgit:git-log[1] manual page.

--name-status::
	Show only names and status of changed files. See the description of the `--diff-filter` option on what the status letters mean. Just like `--name-only` the file names are often encoded in UTF-8.

--submodule[=<格式>]::
	Specify how differences in submodules are shown. When specifying `--submodule=short` the 'short' format is used. This format just shows the names of the commits at the beginning and end of the range. When `--submodule` or `--submodule=log` is specified, the 'log' format is used. This format lists the commits in the range like linkgit:git-submodule[1] `summary` does. When `--submodule=diff` is specified, the 'diff' format is used. This format shows an inline diff of the changes in the submodule contents between the commit range. Defaults to `diff.submodule` or the 'short' format if the config option is unset.

--color[=<when>]::
	Show colored diff. `--color` (i.e. without '=<when>') is the same as `--color=always`. '<when>' can be one of `always`, `never`, or `auto`.
ifdef::git-diff[]
	它可以通过 `color.ui` 和 `color.diff` 来改变
	配置设置。
endif::git-diff[]

--no-color::
	关掉带彩色显示的差异。
ifdef::git-diff[]
	这可以用来覆盖配置设置。
endif::git-diff[]
	这和 `--color=never` 相同。

--color-moved[=<模式>]::
	移动的代码行的颜色不同。
ifdef::git-diff[]
	它可以通过 `diff.colorMoved` 配置设置来改变。
endif::git-diff[]
	如果没有给出该选项，<模式> 默认为 'no'
	如果没有给定模式选项，则为 'zebra'。
	该模式必须以下其中之一：
+
--
no::
	被移动的行不突出显示。
default::
	是 `zebra` 的同义词。今后可能会改成更合理的模式。
plain::
	Any line that is added in one location and was removed in another location will be colored with 'color.diff.newMoved'. Similarly 'color.diff.oldMoved' will be used for removed lines that are added somewhere else in the diff. This mode picks up any moved line, but it is not very useful in a review to determine if a block of code was moved without permutation.
blocks::
	Blocks of moved text of at least 20 alphanumeric characters are detected greedily. The detected blocks are painted using either the 'color.diff.{old,new}Moved' color. Adjacent blocks cannot be told apart.
zebra::
	在 ‘块’ 模式下检测到移动的文本块。块使用 'color.diff.{old,new}Moved' 颜色或 'color.diff.{old,new}MovedAlternative' 颜色。这两种颜色之间的变化表示检测到了新的块。
dimmed-zebra::
	Similar to 'zebra', but additional dimming of uninteresting parts of moved code is performed. The bordering lines of two adjacent blocks are considered interesting, the rest is uninteresting. `dimmed_zebra` is a deprecated synonym.
--

--no-color-moved::
	关闭移动检测。这可以用来覆盖配置设置。它与 `--color-moved=no` 相同。

--color-moved-ws=<模式>::
	这将配置在执行 `--color-moved` 选项的移动检测时如何忽略空格。
ifdef::git-diff[]
	可以通过 `diff.colorMovedWS` 来设置。
endif::git-diff[]
	这些模式可以通过以逗号分隔的列表给出：
+
--
no::
	执行移动检测时不忽略空格。
ignore-space-at-eol::
	忽略行尾空格的变化。
ignore-space-change::
	Ignore changes in amount of whitespace. This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent.
ignore-all-space::
	比较行时忽略空格。即使一行有空格而另一行没有空格，也会忽略差异。
allow-indentation-change::
	在最初移动检测中忽略的任何空格，然后只在每行的空格变化相同的情况下，将移动的代码块归为一个块。这与其他模式是不兼容的。
--

--no-color-moved-ws::
	执行移动检测时，不忽略空格。这可以用来覆盖配置。它与 `--color-moved-ws=no` 相同。

--word-diff[=<模式>]::
	Show a word diff, using the <mode> to delimit changed words. By default, words are delimited by whitespace; see `--word-diff-regex` below. The <mode> defaults to 'plain', and must be one of:
+
--
color::
	Highlight changed words using only colors. Implies `--color`.
plain::
	Show words as `[-removed-]` and `{+added+}`. Makes no attempts to escape the delimiters if they appear in the input, so the output may be ambiguous.
porcelain::
	Use a special line-based format intended for script consumption. Added/removed/unchanged runs are printed in the usual unified diff format, starting with a `+`/`-`/` ` character at the beginning of the line and extending to the end of the line. Newlines in the input are represented by a tilde `~` on a line of its own.
none::
	再次禁用单词差异模式。
--
+
请注意，无论第一个模式的名称是什么，如果启用该选项，将在所有模式中使用颜色，以高亮显示更改的部分。

--word-diff-regex=<正则表达式>::
	Use <regex> to decide what a word is, instead of considering runs of non-whitespace to be a word. Also implies `--word-diff` unless it was already enabled.
+
Every non-overlapping match of the <regex> is considered a word. Anything between these matches is considered whitespace and ignored(!) for the purposes of finding differences. You may want to append `|[^[:space:]]` to your regular expression to make sure that it matches all non-whitespace characters. A match that contains a newline is silently truncated(!) at the newline.
+
例如，`--word-diff-regex=.` 将把每个字符当作一个单词，并相应地逐个字符显示差异。
+
The regex can also be set via a diff driver or configuration option, see linkgit:gitattributes[5] or linkgit:git-config[1]. Giving it explicitly overrides any diff driver or configuration setting. Diff drivers override configuration settings.

--color-words[=<正则表达式>]::
	与 `--word-diff=color` 和（如果指明了正则表达式）`--word-diff-regex=<正则表达式>` 两个选项含义相同。
endif::git-format-patch[]

--no-renames::
	关闭重命名检测，即使配置文件给出的默认是这样做。

--[no-]rename-empty::
	是否使用空的数据对象作为重命名源。

ifndef::git-format-patch[]
--check::
	Warn if changes introduce conflict markers or whitespace errors. What are considered whitespace errors is controlled by `core.whitespace` configuration. By default, trailing whitespaces (including lines that consist solely of whitespaces) and a space character that is immediately followed by a tab character inside the initial indent of the line are considered whitespace errors. Exits with non-zero status if problems are found. Not compatible with --exit-code.

--ws-error-highlight=<种类>::
	Highlight whitespace errors in the `context`, `old` or `new` lines of the diff. Multiple values are separated by comma, `none` resets previous values, `default` reset the list to `new` and `all` is a shorthand for `old,new,context`. When this option is not given, and the configuration variable `diff.wsErrorHighlight` is not set, only whitespace errors in `new` lines are highlighted. The whitespace errors are colored with `color.diff.whitespace`.

endif::git-format-patch[]

--full-index::
	在生成补丁格式输出时，在 `index`（索引）行上显示完整的图像前和图像后数据对象名称，而不仅是前几个字符。

--binary::
	除了 `--full-index` 输出的差异之外，输出二进制的差异。其可以用 `git-apply` 命令来应用。暗含 `--patch` 选项。
ifndef::git-format-patch[]
	暗含 `--patch` 选项。
endif::git-format-patch[]

--abbrev[=<n>]::
	Instead of showing the full 40-byte hexadecimal object name in diff-raw format output and diff-tree header lines, show the shortest prefix that is at least '<n>' hexdigits long that uniquely refers the object. In diff-patch output format, `--full-index` takes higher precedence, i.e. if `--full-index` is specified, full blob names will be shown regardless of `--abbrev`. Non default number of digits can be specified with `--abbrev=<n>`.

-B[<n>][/<m>]::
--break-rewrites[=[<n>][/<m>]]::
	将完整的重写更改切分成删除和创建对（pair）。这有两个目的：
+
它会影响决定更改形式的阈值，当单个文件内修改总量达到一定值时，会认为该文件进行了完全重写，而不是将一系列删除和插入操作视为修改。如果视为多个删除和插入修改，修改中的行可能会碰巧在文本上与原文一致，从而被当作上下文。选项中的数字 `m` 控制 -B 选项的这一方面（默认为 60％）。`-B/70％` 表示，如果在结果中保留的原始内容少于原始内容的30％，则 Git 认为它是完全重写的（否则，生成的补丁将是一系列删除和插入，并与上下文行混合在一起）。
+
使用 -M 选项时，一个完全改写的文件也被认为是重命名文件的来源（通常 -M 只考查一个消失文件作为重命名的来源)。选项中的数量 `n` 控制 -B 选项的这一方面（默认为 50％)。`-B20%` 表明，当插入与删除比 20％ 的文件大小更多，该文件可作为重命名到另一文件的可能来源。

-M[<n>]::
--find-renames[=<n>]::
ifndef::git-log[]
	重命名检测。
endif::git-log[]
ifdef::git-log[]
	如果制成差异，检测并报告每个提交中的重命名。
	对于每个在遍历历史时重命名的文件，参见
	`--follow`。
endif::git-log[]
	如果指定了 `n`，则其为相似度指数阈值（即相比于文件大小的增/删量）。
	例如，`-M90％` 表示如果文件90％以上的内容没有更改，则 Git 应将删除/添加对视为重命名。
	如果没有 `％` 符号，则该数字应作为小数读取，并在其前面加上小数点。
 	即 `-M5` 变为 0.5，因此与 `-M50％` 相同。 同样，`-M05` 与 `-M5％` 相同。
 	要将检测限制为精确的重命名，请使用 `-M100％`。 默认相似度指数为50％。

-C[<n>]::
--find-copies[=<n>]::
	Detect copies as well as renames. See also `--find-copies-harder`. If `n` is specified, it has the same meaning as for `-M<n>`.

--find-copies-harder::
	For performance reasons, by default, `-C` option finds copies only if the original file of the copy was modified in the same changeset. This flag makes the command inspect unmodified files as candidates for the source of copy. This is a very expensive operation for large projects, so use it with caution. Giving more than one `-C` option has the same effect.

-D::
--irreversible-delete::
	删除时省略原内容，即只打印头信息，而不打原内容和 `/dev/null` 之间的差异。所产生的补丁并不是要用于 `patch` 或 `git apply`；这只是为了让人们只专注于审查修改后的文本。此外，输出结果显然缺乏足够的信息来反转，或手动应用这样一个补丁，因此这个选项的名称如此。
+
当与 `-B` 一起使用时，也省略删除/创建对中删除部分的原内容。

-l<数量>::
	The `-M` and `-C` options involve some preliminary steps that can detect subsets of renames/copies cheaply, followed by an exhaustive fallback portion that compares all remaining unpaired destinations to all relevant sources. (For renames, only remaining unpaired sources are relevant; for copies, all original sources are relevant.) For N sources and destinations, this exhaustive check is O(N^2). This option prevents the exhaustive portion of rename/copy detection from running if the number of source/destination files involved exceeds the specified number. Defaults to diff.renameLimit. Note that a value of 0 is treated as unlimited.

ifndef::git-format-patch[]
--diff-filter=[(A|C|D|M|R|T|U|X|B)...[*]]::
	Select only files that are Added (`A`), Copied (`C`), Deleted (`D`), Modified (`M`), Renamed (`R`), have their type (i.e. regular file, symlink, submodule, ...) changed (`T`), are Unmerged (`U`), are Unknown (`X`), or have had their pairing Broken (`B`). Any combination of the filter characters (including none) can be used. When `*` (All-or-none) is added to the combination, all paths are selected if there is any file that matches other criteria in the comparison; if there is no file that matches other criteria, nothing is selected.
+
Also, these upper-case letters can be downcased to exclude. E.g. `--diff-filter=ad` excludes added and deleted paths.
+
请注意，并非所有差异都能显示所有类型。例如，如果禁用了复制和重命名条目类型的检测，这些条目就不会出现。

-S<string>::
	Look for differences that change the number of occurrences of the specified string (i.e. addition/deletion) in a file. Intended for the scripter's use.
+
当您正在寻找确切的代码块（如结构体），并且想知道该块自首次出现以来的历史记录时，这将非常有用：通过 `-S` 选项迭代，将原文件中的感兴趣的块显示出，并继续进行，直到获得该块的第一个版本。
+
二进制文件也会被搜索到。

-G<正则表达式>::
	查找其补丁文本包含与 <正则表达式> 匹配的添加/删除行的差异。
+
为了说明 `-S<正则表达式> --pickaxe-regex` 和 `-G<正则表达式>` 之间的区别，假设某次提交在同一文件中有以下差异：
+
----
+    return frotz(nitfol, two->ptr, 1, 0);
...
-    hit = frotz(nitfol, mf2.ptr, 1, 0);
----
+
`git log -G "frotz\(nitfol"` 会显示这次提交，但 `git log -S "frotz\(nitfol" --pickaxe-regex` 不会显示（因为该字符串的出现次数没有改变）。
+
除非提供 `--text`，否则没有 textconv 过滤器的二进制文件补丁将被忽略。
+
更多信息请参见 linkgit:gitdiffcore[7] 中的 'pickaxe' 条目。

--find-object=<对象ID>::
	查找指定对象出现次数的差异。与 `-S` 类似，只是参数不同：它不搜索特定的字符串，而是搜索特定的对象 id。
+
该对象可以是一个 blob 或一个子模块提交。它意味着 `git-log` 中的 `-t` 选项也能找到工作树。

--pickaxe-all::
	当使用 `-S` 或 `-G` 选项找到一个更改时，显示该更改集中的所有更改，而不仅仅是显示包含 <string> 更改的文件。

--pickaxe-regex::
	将 `-S` 选项的 <string> 参数当作扩展的 POSIX 正则表达式来匹配。

endif::git-format-patch[]

-O<顺序控制文件>::
	Control the order in which files appear in the output. This overrides the `diff.orderFile` configuration variable (see linkgit:git-config[1]). To cancel `diff.orderFile`, use `-O/dev/null`.
+
The output order is determined by the order of glob patterns in <orderfile>. All files with pathnames that match the first pattern are output first, all files with pathnames that match the second pattern (but not the first) are output next, and so on. All files with pathnames that do not match any pattern are output last, as if there was an implicit match-all pattern at the end of the file. If multiple pathnames have the same rank (they match the same pattern but no earlier patterns), their output order relative to each other is the normal order.
+
<顺序控制文件> 格式如下：
+
--
 - 空白行会被忽略，因此可以用它们作为分隔符，以保证可读性。

 - Lines starting with a hash ("`#`") are ignored, so they can be used for comments. Add a backslash ("`\`") to the beginning of the pattern if it starts with a hash.

 - 每一行都包含一个模式。
--
+
Patterns have the same syntax and semantics as patterns used for fnmatch(3) without the FNM_PATHNAME flag, except a pathname also matches a pattern if removing any number of the final pathname components matches the pattern. For example, the pattern "`foo*bar`" matches "`fooasdfbar`" and "`foo/bar/baz/asdf`" but not "`foobarx`".

--skip-to=<文件>::
--rotate-to=<文件>::
	Discard the files before the named <file> from the output (i.e. 'skip to'), or move them to the end of the output (i.e. 'rotate to'). These options were invented primarily for the use of the `git difftool` command, and may not be very useful otherwise.

ifndef::git-format-patch[]
-R::
	交换两个输入；即显示从索引或磁盘文件到目录树内容的差异。
endif::git-format-patch[]

--relative[=<路径>]::
--no-relative::
	When run from a subdirectory of the project, it can be told to exclude changes outside the directory and show pathnames relative to it with this option. When you are not in a subdirectory (e.g. in a bare repository), you can name which subdirectory to make the output relative to by giving a <path> as an argument. `--no-relative` can be used to countermand both `diff.relative` config option and previous `--relative`.

-a::
--text::
	将一切输入文件视为文本。

--ignore-cr-at-eol::
	在进行比较时，忽略行末的回车。

--ignore-space-at-eol::
	忽略行尾空格的变化。

-b::
--ignore-space-change::
	Ignore changes in amount of whitespace. This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent.

-w::
--ignore-all-space::
	比较行时忽略空格。即使一行有空格而另一行没有空格，也会忽略差异。

--ignore-blank-lines::
	忽略空白行的变化。

-I<正则表达式>::
--ignore-matching-lines=<正则表达式>::
	Ignore changes whose all lines match <regex>. This option may be specified more than once.

--inter-hunk-context=<行数>::
	Show the context between diff hunks, up to the specified number of lines, thereby fusing hunks that are close to each other. Defaults to `diff.interHunkContext` or 0 if the config option is unset.

-W::
--function-context::
	Show whole function as context lines for each change. The function names are determined in the same way as `git diff` works out patch hunk headers (see 'Defining a custom hunk-header' in linkgit:gitattributes[5]).

ifndef::git-format-patch[]
ifndef::git-log[]
--exit-code::
	Make the program exit with codes similar to diff(1). That is, it exits with 1 if there were differences and 0 means no differences.

--quiet::
	禁用程序的所有输出。暗含 `--exit-code`。
endif::git-log[]
endif::git-format-patch[]

--ext-diff::
	允许执行外部差异器。如果你用 linkgit:gitattributes[5] 设置了一个外部差异驱动程序，你需要在 linkgit:git-log[1] 和相关命令中使用这个选项。

--no-ext-diff::
	禁止使用外部差异器。

--textconv::
--no-textconv::
	允许（或不允许）在比较二进制文件时运行外部文本转换过滤器。详情请参见 linkgit:gitattributes[5] 。由于文本转换过滤器通常是单向转换，因此产生的差异适合人类用户使用，但不能应用（apply）。因此默认情况下，只有 linkgit:git-diff[1] 和 linkgit:git-log[1] 启用文本转换过滤器，而 linkgit:git-format-patch[1] 或 diff plumbing 命令则不启用。

--ignore-submodules[=<when>]::
	Ignore changes to submodules in the diff generation. <when> can be either "none", "untracked", "dirty" or "all", which is the default. Using "none" will consider the submodule modified when it either contains untracked or modified files or its HEAD differs from the commit recorded in the superproject and can be used to override any settings of the 'ignore' option in linkgit:git-config[1] or linkgit:gitmodules[5]. When "untracked" is used submodules are not considered dirty when they only contain untracked content (but they are still scanned for modified content). Using "dirty" ignores all changes to the work tree of submodules, only changes to the commits stored in the superproject are shown (this was the behavior until 1.7.0). Using "all" hides all changes to submodules.

--src-prefix=<前缀>::
	显示给定的源前缀而不是 "a/"。

--dst-prefix=<前缀>::
	显示给定的目标前缀，而不是“b/”。

--no-prefix::
	不显示任何源或目的前缀。

--default-prefix::
	Use the default source and destination prefixes ("a/" and "b/"). This is usually the default already, but may be used to override config such as `diff.noprefix`.

--line-prefix=<prefix>::
	在每一行输出前加上一个额外的前缀。

--ita-invisible-in-index::
	By default entries added by "git add -N" appear as an existing empty file in "git diff" and a new file in "git diff --cached". This option makes the entry appear as a new file in "git diff" and non-existent in "git diff --cached". This option could be reverted with `--ita-visible-in-index`. Both options are experimental and could be removed in future.

关于这些常用选项的更多解释，请参见 linkgit:gitdiffcore[7]。
[]

[[generate_patch_text_with_p]]
使用选项 `-p` 生成补丁文本
----------------

Running linkgit:git-diff[1], linkgit:git-log[1], linkgit:git-show[1], linkgit:git-diff-index[1], linkgit:git-diff-tree[1], or linkgit:git-diff-files[1] with the `-p` option produces patch text. You can customize the creation of patch text via the `GIT_EXTERNAL_DIFF` and the `GIT_DIFF_OPTS` environment variables (see linkgit:git[1]), and the `diff` attribute (see linkgit:gitattributes[5]).

-p 选项产生的内容与传统的差异格式略有不同：

1.   它前面有一个 `git diff` 头，如下所示：

       diff --git a/file1 b/file2
+
`a/` 和 `b/` 的文件名相同，除非涉及到重命名/复制。特别地，即使是创建或删除，也 _不_ 使用 `/dev/null` 来代替 `a/` 或 `b/` 文件名。
+
当涉及到重命名/复制时，`file1` 和 `file2` 分别显示重命名/复制的源文件的名称和重命名/复制产生的文件的名称。

2.   它的后面是一个或多个扩展头信息行：

       old mode <模式>
       new mode <模式>
       deleted file mode <模式>
       new file mode <模式>
       copy from <路径>
       copy to <路径>
       rename from <路径>
       rename to <路径>
       similarity index <数字>
       dissimilarity index <数字>
       index <哈希>..<哈希> <模式>
+
文件模式被打印为6位八进制数字，包括文件类型和文件权限位。
+
扩展头信息中的路径名称不包括 `a/` 和 `b/` 前缀。
+
相似性指数是未改变的行占比，而不相似性指数是改变的行占比。它是四舍五入的整数，后有百分号。因此，100%的相似度指数指为两个文件相等，而 100% 的不相似度意味着入新文件中没有旧文件中的行。
+
索引行包括改变前和改变后的 blob 对象名称。如果文件模式没有变化，则包含 <模式>；否则，分别显示新旧模式。

3.  含有 "不常见" 字符的路径名会被引用，这一点在配置变量` core.quotePath` 中有所解释（见 linkgit:git-config[1]）。

4.  输出中所有的 `file1` 文件都是指提交前的文件，而所有的 `file2` 文件都是指提交后的文件。按顺序对每个文件进行修改是不正确的。例如，这个补丁将交换文件 a 和 b：

      diff --git a/a b/b
      rename from a
      rename to b
      diff --git a/b b/a
      rename from b
      rename to a

5.  块头提到了块头所适用的函数的名称。 参见 linkgit:gitattributes[5] 中的 "定义自定义 hunk-header"，以了解如何针对特定语言进行定制。


合并的差异格式
-------

任何生成差异的命令都可以使用 `-c` 或 `-cc` 选项，在显示合并时产生一个 "合并差异"。当用 linkgit:git-diff[1] 或 linkgit:git-show[1] 显示合并时，这默认格式。还需要注意的是，你可以给这些命令适当的 `--diff-merges` 选项来强制生成特定格式的差异。

"合并的差异" 的格式如下：

------------
diff --combined describe.c
index fabadb8,cc95eb0..4866510
--- a/describe.c
+++ b/describe.c
@@@ -98,20 -98,12 +98,20 @@@
	return (a_date > b_date) ? -1 : (a_date == b_date) ? 0 : 1;
  }

- static void describe(char *arg)
 -static void describe(struct commit *cmit, int last_one)
++static void describe(char *arg, int last_one)
  {
 +	unsigned char sha1[20];
 +	struct commit *cmit;
	struct commit_list *list;
	static int initialized = 0;
	struct commit_name *n;

 +	if (get_sha1(arg, sha1) < 0)
 +		usage(describe_usage);
 +	cmit = lookup_commit_reference(sha1);
 +	if (!cmit)
 +		usage(describe_usage);
 +
	if (!initialized) {
		initialized = 1;
		for_each_ref(get_name);
------------

1.   它前面有 "git diff" 头，如下（当使用 `c` 选项时）：

       diff --combined file
+
或如下（当使用 `--cc` 选项时）：

       diff --cc file

2.   它的后面是一个或多个扩展头信息行（本例显示的是与两个父提交的合并）：

       index <哈希>,<哈希>..<哈希>
       mode <模式>,<模式>..<模式>
       new file mode <模式>
       deleted file mode <模式>,<模式>
+
The `mode <mode>,<mode>..<mode>` line appears only if at least one of the <mode> is different from the rest. Extended headers with information about detected contents movement (renames and copying detection) are designed to work with diff of two <tree-ish> and are not used by combined diff format.

3.   它的后面是两行源文件/目标文件的头信息

       --- a/file
       +++ b/file
+
类似于传统的 "统一" 差异格式的双行头，`/dev/null` 用来表示创建或删除的文件。
+
但是，如果提供了 --combined-all-paths 选项，你就会得到一个 N+1 行的源文件/目标文件头，其中 N 是合并提交中的父提交数量

       --- a/file
       --- a/file
       --- a/file
       +++ b/file
+
如果重命名或复制检测处于活动状态，这种扩展格式可能很有用，可以让你在不同的父提交中看到文件的原始名称。

4.   修改了文件块头信息的格式，以防止不小心将其送入 `patch -p1`。合并的差异格式是为审查合并提交的修改而创建的，并不是为了应用。这个变化类似于扩展的 "索引" 头信息的变化：

       @@@ <from-file-range> <from-file-range> <to-file-range> @@@
+
块中有（父提交数量+1）`@` 字符，用于合并的差异格式。

与传统的 "统一" 差异格式不同，这种格式显示两个文件 A 和 B 的列，其中有 `-`（减号 -- 在 A 中出现，但在 B 中删除），`+`（加号 -- 在 A 中缺少，但在 B 中增加），或 `" "`（空格 -- 不变）前缀，这种格式比较两个或多个文件与一个文件 X，并显示 X 与其中每个文件的差异。文件中的每一个都有一列被前置在输出行中，以指出 X 的行与它的不同之处。

第 N 列中的 `-` 字符意味着该行出现在文件 N 中，但它没有出现在结果文件中。第 N 列中的 `+` 字符意味着该行出现在结果文件中，而文件 N 中没有该行（换句话说，从该父提交的角度来看，该行是被添加的）。

在上面的输出示例中，两个文件中的函数签名都被改变了（因此从文件 1 和文件 2 中都有表示删除的 `-`，而 `++` 表示被添加的一行没有出现在文件 1 或文件 2 中）。另外还有 8 行与文件 1 中的相同，但没有出现在文件 2 中（因此前缀为 `+`）。

当用 `git diff-tree -c` 显示时，它将合并提交的父提交文件与合并结果进行比较（即文件 1 ... 文件 N 是父提交文件）。当用 `git diff-files -c` 显示时，它将两个未解决的合并父提交文件与工作树文件进行比较（即文件 1 是阶段 2 ，又称 "我们的版本"，文件 2 是阶段 3，又称 "他们的版本"）。
[]

实例
--
`git log --no-merges`::

	显示整个提交历史，但跳过任何合并内容

`git log v2.6.12.. include/scsi drivers/scsi`::

	显示自版本 'v2.6.12' 以来改变 `include/scsi` 或 `drivers/scsi` 子目录中任何文件的所有提交

`git log --since="2 weeks ago" -- gitk`::

	Show the changes during the last two weeks to the file 'gitk'. The `--` is necessary to avoid confusion with the *branch* named 'gitk'

`git log --name-status release..test`::

	显示在 "test "分支中但尚未在 "release "分支中的提交，以及每个提交修改的路径列表。

`git log --follow builtin/rev-list.c`::

	显示改变`builtin/rev-list.c`的提交，包括那些在文件被赋予现在名字之前发生的提交。

`git log --branches --not --remotes=origin`::

	显示所有在本地分支中但不在 "origin "的远程跟踪分支中的提交（你有而origin没有的东西）。

`git log master --not --remotes=*/master`::

	显示所有在本地主库但不在任何远程仓库主库分支中的提交。

`git log -p -m --first-parent`::

	Shows the history including change diffs, but only from the ``main branch'' perspective, skipping commits that come from merged branches, and showing full diffs of changes introduced by the merges. This makes sense only when following a strict policy of merging all topic branches when staying on a single integration branch.

`git log -L '/int main/',/^}/:main.c`::

	显示了文件`main.c`中的函数`main()`是如何随时间演变的。

`git log -3`::

	将显示的提交数量限制在3个。

讨论
--

Git在某种程度上是与字符编码无关的。

 - blob对象的内容是未经解释的字节序列。 在核心层没有编码转换。

 - 路径名以UTF-8规范化形式C编码，这适用于树对象、索引文件、参考名称，以及命令行参数、环境变量和配置文件（`.git/config`（见linkgit:git-config[1]），linkgit:gitignore[5]，linkgit:gitattributes[5] 和linkgit:gitmodules[5]）中的路径名。
+
请注意，Git 在核心层将路径名简单地视为非 NUL 字节的序列，没有路径名编码的转换（除了 Mac 和 Windows）。因此，即使在使用传统的扩展ASCII编码的平台和文件系统上，使用非ASCII的路径名大多也能工作。然而，在这种系统上创建的仓库在基于UTF-8的系统（如Linux、Mac、Windows）上将无法正常工作，反之亦然。 此外，许多基于Git的工具简单地认为路径名称是UTF-8，而不能正确显示其他编码。

 - 提交日志信息通常以UTF-8编码，但也支持其他扩展ASCII编码。这包括ISO-8859-x、CP125x和其他许多编码，但不包括UTF-16/32、EBCDIC和CJK多字节编码（GBK、Shift-JIS、Big5、EUC-x、CP9xx等）。

尽管我们鼓励提交日志信息使用UTF-8编码，但核心系统和Git Porcelain的设计并不强制要求项目使用UTF-8。 如果某个项目的所有参与者都认为使用传统编码更方便，Git也不会禁止。 然而，有几件事需要注意。

. git commit "和 "git commit-tree "如果收到的提交日志信息不像是有效的UTF-8字符串，就会发出警告，除非你明确表示你的项目使用的是传统编码。 说这个的方法是在`.git/config`文件中设置`i18n.commitEncoding`，像这样。
+
------------
[i18n]
	commitEncoding = ISO-8859-1
------------
+
用上述设置创建的提交对象在其`encoding`头中记录了`i18n.commitEncoding`的值。 这是为了帮助以后看这些对象的人。 缺少这个头意味着提交日志信息是以UTF-8编码的。

. 'git log', 'git show', 'git blame' and friends look at the `encoding` header of a commit object, and try to re-code the log message into UTF-8 unless otherwise specified. You can specify the desired output encoding with `i18n.logOutputEncoding` in `.git/config` file, like this:
+
------------
[i18n]
	logOutputEncoding = ISO-8859-1
------------
+
如果你没有这个配置变量，则使用`i18n.commitEncoding`的值来代替。

请注意，我们特意选择在提交对象层面上，不对提交日志信息进行重新编码，因为重新编码为UTF-8不一定是一个可逆的操作。
[]

配置
--

核心变量见 linkgit:git-config[1] ，与 diff 生成相关的设置见 linkgit:git-diff[1] 。

format.pretty::
	Default for the `--format` option. (See 'Pretty Formats' above.) Defaults to `medium`.

i18n.logOutputEncoding::
	Encoding to use when displaying logs. (See 'Discussion' above.) Defaults to the value of `i18n.commitEncoding` if set, and UTF-8 otherwise.



[WARNING]
====
Missing `zh_HANS-CN/includes/cmd-config-section-rest.txt`

See original version for this content.
====

[]



[WARNING]
====
Missing `zh_HANS-CN/config/log.txt`

See original version for this content.
====

[]



[WARNING]
====
Missing `zh_HANS-CN/config/notes.txt`

See original version for this content.
====

[]

GIT
---
属于 linkgit:git[1] 文档
