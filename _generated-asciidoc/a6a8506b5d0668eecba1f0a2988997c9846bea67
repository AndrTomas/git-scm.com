git-rev-parse(1)
================

名称
--
git-rev-parse - 挑选并调整参数


概述
--
[verse]
'git rev-parse' [<选项>] <参数>...

描述
--

Many Git porcelainish commands take a mixture of flags (i.e. parameters that begin with a dash '-') and parameters meant for the underlying 'git rev-list' command they use internally and flags and parameters for the other commands they use downstream of 'git rev-list'. This command is used to distinguish between them.


选项
--

操作模式
~~~~

这些选项都必须在命令行中首先出现。

--parseopt::
	在选项解析模式下使用 'git rev-parse' （见下文 PARSEOPT 部分）。

--sq-quote::
	在 shell 引用模式下使用 'git rev-parse'（见下文 SQ-QUOTE 部分）。与下面的 `--sq` 选项不同，该模式只进行引用。对命令输入不做任何其他处理。

--parseopt 的选项
~~~~~~~~~~~~~~

--keep-dashdash::
	仅在 `--parseopt` 模式下有效。告诉选项解析器回显第一个`--` 而不是跳过它。

--stop-at-non-option::
	Only meaningful in `--parseopt` mode. Lets the option parser stop at the first non-option argument. This can be used to parse sub-commands that take options themselves.

--stuck-long::
	仅在 `--parseopt` 模式下有效。如果有的话，以长形式输出选项，并保留参数。

筛选选项
~~~~

--revs-only::
	不输出与 'git rev-list' 命令无关的标志和参数。

--no-revs::
	不输出用于 'git rev-list' 命令的标志和参数。

--flags::
	不输出非标志参数。

--no-flags::
	不输出标记参数。

输出选项
~~~~

--default <参数>::
	如果用户没有提供参数，则使用 `<参数>` 代替。

--prefix <参数>::
	Behave as if 'git rev-parse' was invoked from the `<arg>` subdirectory of the working tree. Any relative filenames are resolved as if they are prefixed by `<arg>` and will be printed in that form.
+
This can be used to convert arguments to a command run in a subdirectory so that they can still be used after moving to the top-level of the repository. For example:
+
----
prefix=$(git rev-parse --show-prefix)
cd "$(git rev-parse --show-toplevel)"
# rev-parse 提供 'set' 所需的 --
eval "set $(git rev-parse --sq --prefix "$prefix" -- "$@")"
----

--verify::
	验证是否正好提供了一个参数，并且该参数可以转化为原始的 20 字节 SHA-1 用于访问对象数据库。如果可以，则将其输出到标准输出；否则，出错。
+
If you want to make sure that the output actually names an object in your object database and/or can be used as a specific type of object you require, you can add the `^{type}` peeling operator to the parameter. For example, `git rev-parse "$VAR^{commit}"` will make sure `$VAR` names an existing object that is a commit-ish (i.e. a commit, or an annotated tag that points at a commit). To make sure that `$VAR` names an existing object of any type, `git rev-parse "$VAR^{object}"` can be used.
+
请注意，如果要验证来自不可信来源的名称，最好使用 `--end-of-options`，以免名称参数被误认为其他选项。

-q::
--quiet::
	Only meaningful in `--verify` mode. Do not output an error message if the first argument is not a valid object name; instead exit with non-zero status silently. SHA-1s for valid object names are printed to stdout on success.

--sq::
	Usually the output is made one line per flag and parameter. This option makes output a single line, properly quoted for consumption by shell. Useful when you expect your parameter to contain whitespaces and newlines (e.g. when using pickaxe `-S` with 'git diff-{asterisk}'). In contrast to the `--sq-quote` option, the command input is still interpreted as usual.

--short[=length]::
	与 `--verify` 模式相同，但会将对象名称缩短为至少包含 `长度` 字符的唯一前缀。最小长度为 4，默认值为配置变量 `core.abbrev` 的有效值（参见 linkgit:git-config[1]）。

--not::
	显示对象名称时，以 '{caret}' 作为前缀，并从已有前缀的对象名称中去掉 '{caret}'。

--abbrev-ref[=(strict|loose)]::
	A non-ambiguous short name of the objects name. The option core.warnAmbiguousRefs is used to select the strict abbreviation mode.

--symbolic::
	通常情况下，对象名称以 SHA-1 形式输出（可能带有 '{caret}' 前缀）；该选项使其输出形式尽可能接近原始输入。

--symbolic-full-name::
	这与 --symbolic 类似，但它会省略非引用输入（即分支或标记名称；或更明确的消歧义 "heads/master" 形式，当你想命名 "master" 分支时，却有一个不幸命名为 "master" 的标记），而显示为完整的引用名称（例如 "refs/heads/master"）。

对象选项
~~~~

--all::
	显示在 `refs/` 中找到的所有引用。

--branches[=pattern]::
--tags[=pattern]::
--remotes[=pattern]::
	分别显示所有分支、标记或远程跟踪分支（即分别在 `refs/heads`、`refs/tags` 或 `refs/remotes`中找到的引用）。
+
If a `pattern` is given, only refs matching the given shell glob are shown. If the pattern does not contain a globbing character (`?`, `*`, or `[`), it is turned into a prefix match by appending `/*`.

--glob=pattern::
	Show all refs matching the shell glob pattern `pattern`. If the pattern does not start with `refs/`, this is automatically prepended. If the pattern does not contain a globbing character (`?`, `*`, or `[`), it is turned into a prefix match by appending `/*`.

--exclude=<通配符模式>::
	不包括匹配"<glob-pattern>"的参考文献，否则下一个`--all`、`--branches`、`--tags`、`--remotes`或`--glob`会考虑这些参考文献。重复这个选项可以累积排除模式，直到下一个`----all`、`---branches`、`---tags`、`---remotes`或`---glob`选项（其他选项或参数不清除累积模式）。
+
当应用于 `--branches`、 `--tags` 或 `--remotes` 时，所给出的模式不应以 `refs/heads`、`refs/tags` 或 `refs/remotes` 开头；当应用于 `--glob` 或 `--all` 选项时，必须以 `refs/` 开头。如果要使用尾部的 '/{asterisk}'，则必须明确给出。

--exclude-hidden=[fetch|receive|uploadpack]::
	通过查阅相应的 `fetch.hideRefs` 、`receive.hideRefs` 或 `uploadpack.hideRefs` 配置和 `transfer.hideRefs` 配置（参见 linkgit:git-config[1]），不要包含会被 `git-fetch` 、`git-receive-pack` 或 `git-upload-pack` 隐藏的引用。该选项会影响下一个伪引用选项 `--all` 或 `--glob`，并在处理后清除。

--disambiguate=<前缀>::
	Show every object whose name begins with the given prefix. The <prefix> must be at least 4 hexadecimal digits long to avoid listing each and every object in the repository by mistake.

文件选项
~~~~

--local-env-vars::
	List the GIT_* environment variables that are local to the repository (e.g. GIT_DIR or GIT_WORK_TREE, but not GIT_EDITOR). Only the names of the variables are listed, not their value, even if they are set.

--path-format=(absolute|relative)::
	Controls the behavior of certain other options. If specified as absolute, the paths printed by those options will be absolute and canonical. If specified as relative, the paths will be relative to the current working directory if that is possible. The default is option specific.
+
该选项可以多次指定，并且只影响命令行中该选项后面的参数，要么影响到命令行的末尾，要么影响到该选项的下一个实例。

以下选项会被 `--path-format` 修改：

--git-dir::
	如果已定义，则显示 `$GIT_DIR`。否则显示 .git 目录的路径。如果是相对路径，则显示当前工作目录的相对路径。
+
如果未定义 `$GIT_DIR`，且未检测到当前目录位于 Git 仓库或工作区中，则向标准错误流打印一条信息，并以非零状态退出。

--git-common-dir::
	如果定义了 `$GIT_COMMON_DIR`，则显示 `$GIT_COMMON_DIR` ，否则显示 `$GIT_DIR`。

--resolve-git-dir <路径>::
	Check if <path> is a valid repository or a gitfile that points at a valid repository, and print the location of the repository. If <path> is a gitfile then the resolved path to the real repository is printed.

--git-path <路径>::
	解析 "$GIT_DIR/<路径>"，并考虑其他路径重定位变量，如 $GIT_OBJECT_DIRECTORY、$GIT_INDEX_FILE...。例如，如果 $GIT_OBJECT_DIRECTORY 设置为 /foo/bar，那么 "git rev-parse --git-path objects/abc" 就会返回 /foo/bar/abc。

--show-toplevel::
	显示工作树顶层目录的路径（默认为绝对路径）。如果没有工作区，则会报错。

--show-superproject-working-tree::
	Show the absolute path of the root of the superproject's working tree (if exists) that uses the current repository as its submodule. Outputs nothing if the current repository is not used as a submodule by any project.

--shared-index-path::
	在分割索引模式下显示共享索引文件的路径，如果不在分割索引模式下则显示空路径。

以下选项不受 `--path-format` 影响：

--absolute-git-dir::
	类似于 `--git-dir`，但其输出始终是规范化的绝对路径。

--is-inside-git-dir::
	当当前工作目录低于仓库目录时，打印 "true"，否则打印 "false"。

--is-inside-work-tree::
	当当前工作目录位于仓库工作区内时，打印 "true"，否则打印 "false"。

--is-bare-repository::
	当仓库为裸仓库时，打印 "true"，否则打印 "false"。

--is-shallow-repository::
	当仓库是浅克隆时打印 "true"，否则打印 "false"。

--show-cdup::
	从子目录调用命令时，显示顶层目录相对于当前目录的路径（通常是 ".../" 序列或空字符串）。

--show-prefix::
	从子目录调用命令时，显示当前目录相对于顶层目录的路径。

--show-object-format[=(storage|input|output)]::
	Show the object format (hash algorithm) used for the repository for storage inside the `.git` directory, input, or output. For input, multiple algorithms may be printed, space-separated. If not specified, the default is "storage".

--show-ref-format::
	Show the reference storage format used for the repository.


其他选项
~~~~

--since=datestring::
--after=datestring::
	解析日期字符串，并为 'git rev-list' 输出相应的 --max-age= 参数。

--until=datestring::
--before=datestring::
	解析日期字符串，并为 'git rev-list' 输出相应的 --min-age= 参数。

<多个参数>...::
	要解析的标志和参数。


规定修订
----

A revision parameter '<rev>' typically, but not necessarily, names a commit object. It uses what is called an 'extended SHA-1' syntax. Here are various ways to spell object names. The ones listed near the end of this list name trees and blobs contained in a commit.

NOTE: 本文档显示的是 git 所看到的 “原始” 语法。shell 和其他用户界面可能需要额外的引号来保护特殊字符和避免分词。

'<sha1>', e.g. 'dae86e1950b1277e545cee180551750029cfe735', 'dae86e'::
  The full SHA-1 object name (40-byte hexadecimal string), or a leading substring that is unique within the repository. E.g. dae86e1950b1277e545cee180551750029cfe735 and dae86e both name the same commit object if there is no other object in your repository whose object name starts with dae86e.

'<describeOutput（描述输出）>'，例如 'v1.7.4.2-679-g3bee7fb'::
  来自 `git describe` 的输出；即一个最接近的标记，后面可选择一个破折号和提交次数，再后面是一个破折号、一个 'g' 和一个缩写的对象名称。

'<引用名>'， 例如 'master', 'heads/master', 'refs/heads/master'::
  A symbolic ref name. E.g. 'master' typically means the commit object referenced by 'refs/heads/master'. If you happen to have both 'heads/master' and 'tags/master', you can explicitly say 'heads/master' to tell Git which one you mean. When ambiguous, a '<refname>' is disambiguated by taking the first match in the following rules:
+
  . 如果'$GIT_DIR/<引用名>' 存在，这就是你的意思（这通常只对 `HEAD`、`FETCH_HEAD`、`ORIG_HEAD`、`MERGE_HEAD`、`REBASE_HEAD`、`REVERT_HEAD`、`CHERRY_PICK_HEAD`、`BISECT_HEAD` 和 `AUTO_MERGE` 有用）;

  . 否则，如果存在，则使用 'refs/<引用名>';

  . 否则，如果存在 'refs/tags/<引用名>'，则使用 'refs/tags/<引用名>';

  . 否则，如果存在 'refs/heads/<引用名>'，则使用 'refs/heads/<引用名>';

  . 否则，如果存在 'refs/remotes/<引用名>'，则使用 'refs/remotes/<引用名>';

  . 否则，如果存在 'refs/remotes/<引用名>/HEAD'，则使用 'refs/remotes/<引用名>/HEAD'。

+
  `HEAD`:::
    命名工作区中的更改所基于的提交。
  `FETCH_HEAD`:::
    记录您上次调用 `git fetch` 时
    从远程仓库获取的分支。
  `ORIG_HEAD`:::
    命令（`git am`、`git merge`、`git rebase`、`git reset`）时创建的，
    用于记录这些命令执行前`HEAD`的位置，
    以便于将分支的顶端
    改回执行这些命令前的状态。
  `MERGE_HEAD`:::
    记录您在运行 `git merge` 时
    要合并到分支中的提交。
  `REBASE_HEAD`:::
    会记录当前停止操作的提交，
    原因可能是冲突或
    交互式变基中的 `edit` 命令。
  `REVERT_HEAD`:::
    记录您在运行 `git revert` 时要还原的提交。
  `CHERRY_PICK_HEAD`:::
    会记录您在运行 `git cherry-pick` 时
    要 cherry-pick 的提交。
  `BISECT_HEAD`:::
    记录运行 `git bisect --no-checkout` 时
    要测试的当前提交。
  `AUTO_MERGE`:::
    当合并操作导致冲突时，
    记录与 'ort' 合并策略写入工作树的状态
    相对应的树对象。

+
Note that any of the 'refs/*' cases above may come either from the `$GIT_DIR/refs` directory or from the `$GIT_DIR/packed-refs` file. While the ref name encoding is unspecified, UTF-8 is preferred as some output processing may assume ref names in UTF-8.

'@'::
  '@' 本身就是 `HEAD` 的快捷方式。

'[<引用名>]@{<日期>}', 例如： 'master@\{yesterday\}', 'HEAD@{5 minutes ago}'::
  A ref followed by the suffix '@' with a date specification enclosed in a brace pair (e.g. '\{yesterday\}', '{1 month 2 weeks 3 days 1 hour 1 second ago}' or '{1979-02-26 18:30:00}') specifies the value of the ref at a prior point in time. This suffix may only be used immediately following a ref name and the ref must have an existing log ('$GIT_DIR/logs/<ref>'). Note that this looks up the state of your *local* ref at a given time; e.g., what was in your local 'master' branch last week. If you want to look at commits made during certain times, see `--since` and `--until`.

'<引用名>@{<n>}', e.g. 'master@\{1\}'::
  A ref followed by the suffix '@' with an ordinal specification enclosed in a brace pair (e.g. '\{1\}', '\{15\}') specifies the n-th prior value of that ref. For example 'master@\{1\}' is the immediate prior value of 'master' while 'master@\{5\}' is the 5th prior value of 'master'. This suffix may only be used immediately following a ref name and the ref must have an existing log ('$GIT_DIR/logs/<refname>').

'@{<n>}', e.g. '@\{1\}'::
  你可以使用带有空引用部分的"@"结构来获取当前分支的引用日志条目。例如，如果你在分支 'blabla' 上，那么 '@\{1\}' 与 'blabla@\{1\}' 的意思相同。

'@{-<n>}', e.g. '@{-1}'::
  结构体 '@{-<n>}' 表示在当前分支/提交之前签出的第 <n> 个分支/提交。

'[<分支名>]@\{upstream\}', e.g. 'master@\{upstream\}', '@\{u\}'::
  分支 B 可以设置为在远程 R 的分支 X（使用 `branch.<名称>.merge` 配置）（使用 `branch.<名称>.remote`配置）之上构建。B@{u} 指的是远程 R 分支 X 的远程跟踪分支，通常位于 `refs/remotes/R/X`。

'[<分支名>]@\{push\}', e.g. 'master@\{push\}', '@\{push\}'::
  后缀 '@\{push}' 报告的是在 `branchname` 签出时运行 `git push` 时 “我们会推送到哪里” 的分支（如果没有指定分支名，则报告当前的 `HEAD`）。就像 '@\{upstream\}' 一样，我们会报告与该分支相对应的远程跟踪分支。
+
这里有一个例子，可以更清楚地说明这一点:
+
------------------------------
$ git config push.default current
$ git config remote.pushdefault myfork
$ git switch -c mybranch origin/master

$ git rev-parse --symbolic-full-name @{upstream}
refs/remotes/origin/master

$ git rev-parse --symbolic-full-name @{push}
refs/remotes/myfork/mybranch
------------------------------
+
请注意，我们在示例中设置了一个三角工作流，即从一个位置提取数据，然后推送到另一个位置。在非三角工作流中，'@\{push}' 与 '@\{upstream}' 相同，没有必要使用。
+
这个后缀用大写字母拼写时也被接受，无论大小写，意思都一样。

'<修订号>{caret}[<n>]'，例如 'HEAD{caret}, v1.5.1{caret}0'::
  A suffix '{caret}' to a revision parameter means the first parent of that commit object. '{caret}<n>' means the <n>th parent (i.e. '<rev>{caret}' is equivalent to '<rev>{caret}1'). As a special rule, '<rev>{caret}0' means the commit itself and is used when '<rev>' is the object name of a tag object that refers to a commit object.

'<修订>{tilde}[<n>]', e.g. 'HEAD{tilde}, master{tilde}3'::
  A suffix '{tilde}' to a revision parameter means the first parent of that commit object. A suffix '{tilde}<n>' to a revision parameter means the commit object that is the <n>th generation ancestor of the named commit object, following only the first parents. I.e. '<rev>{tilde}3' is equivalent to '<rev>{caret}{caret}{caret}' which is equivalent to '<rev>{caret}1{caret}1{caret}1'. See below for an illustration of the usage of this form.

'<修订>{caret}{<类型>}', e.g. 'v0.99.8{caret}\{commit\}'::
  A suffix '{caret}' followed by an object type name enclosed in brace pair means dereference the object at '<rev>' recursively until an object of type '<type>' is found or the object cannot be dereferenced anymore (in which case, barf). For example, if '<rev>' is a commit-ish, '<rev>{caret}\{commit\}' describes the corresponding commit object. Similarly, if '<rev>' is a tree-ish, '<rev>{caret}\{tree\}' describes the corresponding tree object. '<rev>{caret}0' is a short-hand for '<rev>{caret}\{commit\}'.
+
'<修订>{caret}/{object/}' 可以用来确保 '<修订>' 命名了一个存在的对象，而不要求 '<修订>' 是一个标记，也不需要取消引用 '<修订>'；因为一个标记已经是一个对象，所以即使取消引用一次也不一定能找到一个对象。
+
可以使用 '<修订>{caret}/{tag\}' 来确保 '<修订>' 标识现有的标记对象。

'<rev>{caret}{}', e.g. 'v0.99.8{caret}{}'::
  后缀 '{caret}' 后跟一个空括号对，表示该对象可能是一个标记，并递归引用该标记，直到找到一个非标记对象。

'<修订>{caret}{/<文本>}'，例如 'HEAD^{/fix nasty bug（修复讨厌的 BUG）}'::
  版本参数的后缀 '{caret}'，后面是包含以斜线为首的文本的括号对，与下面的 ':/fix nasty bug' 语法相同，但它返回的是 '{caret}' 之前的 '<修订>' 中最年轻的匹配提交。

':/<文本>'，例如 ':/fix nasty bug'::
  A colon, followed by a slash, followed by a text, names a commit whose commit message matches the specified regular expression. This name returns the youngest matching commit which is reachable from any ref, including HEAD. The regular expression can match any part of the commit message. To match messages starting with a string, one can use e.g. ':/^foo'. The special sequence ':/!' is reserved for modifiers to what is matched. ':/!-foo' performs a negative match, while ':/!!foo' matches a literal '!' character, followed by 'foo'. Any other sequence beginning with ':/!' is reserved for now. Depending on the given text, the shell's word splitting rules might require additional quoting.

'<修订>:<路径>'，例如 'HEAD:README', 'master:./README'::
  A suffix ':' followed by a path names the blob or tree at the given path in the tree-ish object named by the part before the colon. A path starting with './' or '../' is relative to the current working directory. The given path will be converted to be relative to the working tree's root directory. This is most useful to address a blob or tree from a commit or tree that has the same tree structure as the working tree.

':[<n>:]<路径>', e.g. ':0:README', ':README'::
  一个冒号（可选）后面跟一个阶段编号（0 至 3）和一个冒号，冒号后面跟一个路径，用于命名索引中位于给定路径的 Blob 对象。如果缺少阶段号（以及后面的冒号），则命名为阶段 0 条目。在合并过程中，阶段 1 是共同祖先，阶段 2 是目标分支的版本（通常是当前分支），阶段 3 是被合并分支的版本。

Here is an illustration, by Jon Loeliger. Both commit nodes B and C are parents of commit node A. Parent commits are ordered left-to-right.

........................................
G   H   I   J
 \ /     \ /
  D   E   F
   \  |  / \
    \ | /   |
     \|/    |
      B     C
       \   /
        \ /
         A
........................................

    A =      = A^0
    B = A^   = A^1     = A~1
    C =      = A^2
    D = A^^  = A^1^1   = A~2
    E = B^2  = A^^2
    F = B^3  = A^^3
    G = A^^^ = A^1^1^1 = A~3
    H = D^2  = B^^2    = A^^^2  = A~2^2
    I = F^   = B^3^    = A^^3^
    J = F^2  = B^3^2   = A^^3^2


指定范围
----

历史记录遍历命令，如 `git log` 会对一组提交进行操作，而不仅仅是单个提交。

对于这些命令，使用上一节中描述的符号指定一个修订版本，意味着从给定的提交开始 `可达到` 的一组提交。

指定多个修订版本指的是可从任何给定的提交版本到达的提交版本集。

提交的可达集合是指提交本身及其祖先链中的提交。

有几种符号可以指定一组相连的提交（称为 “修订范围”），如下图所示。


排除提交
~~~~

'{caret}<修订号>'（catet）表示::
 To exclude commits reachable from a commit, a prefix '{caret}' notation is used. E.g. '{caret}r1 r2' means commits reachable from 'r2' but exclude the ones reachable from 'r1' (i.e. 'r1' and its ancestors).

虚线范围符号
~~~~~~

'..'（双点）范围符号::
 The '{caret}r1 r2' set operation appears so often that there is a shorthand for it. When you have two commits 'r1' and 'r2' (named according to the syntax explained in SPECIFYING REVISIONS above), you can ask for commits that are reachable from r2 excluding those that are reachable from r1 by '{caret}r1 r2' and it can be written as 'r1..r2'.

'\...'（三点）对称差符号::
 A similar notation 'r1\...r2' is called symmetric difference of 'r1' and 'r2' and is defined as 'r1 r2 --not $(git merge-base --all r1 r2)'. It is the set of commits that are reachable from either one of 'r1' (left side) or 'r2' (right side) but not from both.

In these two shorthand notations, you can omit one end and let it default to HEAD. For example, 'origin..' is a shorthand for 'origin..HEAD' and asks "What did I do since I forked from the origin branch?" Similarly, '..origin' is a shorthand for 'HEAD..origin' and asks "What did the origin do since I forked from them?" Note that '..' would mean 'HEAD..HEAD' which is an empty range that is both reachable and unreachable from HEAD.

Commands that are specifically designed to take two distinct ranges (e.g. "git range-diff R1 R2" to compare two ranges) do exist, but they are exceptions. Unless otherwise noted, all "git" commands that operate on a set of commits work on a single revision range. In other words, writing two "two-dot range notation" next to each other, e.g.

    $ git log A..B C..D

does *not* specify two revision ranges for most commands. Instead it will name a single connected set of commits, i.e. those that are reachable from either B or D but are reachable from neither A or C. In a linear history like this:

    ---A---B---o---o---C---D

因为 A 和 B 可以从 C 处到达，所以这两个虚线范围指定的修订范围是单一的提交 D。


其他 <修订号>{caret}父级速记符号
~~~~~~~~~~~~~~~~~~~~~
还有其他三种简称，特别适用于合并提交，用于命名由提交及其父提交组成的集合。

'r1{caret}@' 表示 'r1' 的所有父代。

The 'r1{caret}!' notation includes commit 'r1' but excludes all of its parents. By itself, this notation denotes the single commit 'r1'.

'<修订号>{caret}-[<n>]' 符号包括 '<修订号>' ，但不包括第 <n> 次父提交（即 '<修订号>{caret}<n>..<修订号>' 的速记形式），如果没有给出，则 '<n>'= 1。这对合并提交非常有用，只需传递 '<提交号>{caret}-'，就能获得在合并提交 '<提交号>' 中被合并的分支的所有提交（包括 '<提交号>' 本身）。

虽然 '<修订号>{caret}<n>' 是指定单个提交的父提交，但这三种符号也会考虑其父提交。例如，你可以说 'HEAD{caret}2{caret}@'，但不能说 'HEAD{caret}@{caret}2'。

修订范围摘要
------

'<rev>'::
	包括可从 <修订号> 到达的提交（即 <修订号> 及其祖先）。

'{caret}<修订号>'::
	排除可从 <修订号> 到达的提交（即 <修订号> 及其祖先）。

'<rev1>..<rev2>'::
	Include commits that are reachable from <rev2> but exclude those that are reachable from <rev1>. When either <rev1> or <rev2> is omitted, it defaults to `HEAD`.

'<修订号1>\...<修订号2>'::
	Include commits that are reachable from either <rev1> or <rev2> but exclude those that are reachable from both. When either <rev1> or <rev2> is omitted, it defaults to `HEAD`.

'<修订>{caret}@', e.g. 'HEAD{caret}@'::
  后缀 '{caret}' 后跟一个 at(@) 符号，就等于列出了 '<修订号>' 的所有父提交（意思是，包括父提交中可触及的任何内容，但不包括提交本身）。

'<修订号>{caret}!'，例如 'HEAD{caret}!'::
  带感叹号的后缀 '{caret}' 与提交 '<修订号>' 及其所有前缀为 '{caret}' 的父节点相同，都是为了排除它们（及其祖先）。

'<修订号>{caret}-<n>'，例如 'HEAD{caret}-, HEAD{caret}-2'::
	等价于 '<修订号>{caret}<n>..<修订号>'，如果未给出，则 '<n>'= 1。

下面是一些使用上述 Loeliger 插图的示例，其中仔细说明了符号扩展和选择的每个步骤：

....
   参数   扩展参数    选定的提交
   D                            G H D
   D F                          G H I J D F
   ^G D                         H D
   ^D B                         E I J F B
   ^D B C                       E I J F B C
   C                            I J F C
   B..C   = ^B C                C
   B...C  = B ^F C              G H D E B C
   B^-    = B^..B
	  = ^B^1 B              E I J F B
   C^@    = C^1
	  = F                   I J F
   B^@    = B^1 B^2 B^3
	  = D E F               D G H E F I J
   C^!    = C ^C^@
	  = C ^C^1
	  = C ^F                C
   B^!    = B ^B^@
	  = B ^B^1 ^B^2 ^B^3
	  = B ^D ^E ^F          B
   F^! D  = F ^I ^J D           G H D F
....
[]

PARSEOPT
--------

在 `--parseopt` 模式下，'git rev-parse' 可以帮助处理选项，为 shell 脚本带来与 C 语言内置程序相同的功能。它可以作为一个选项规范化器工作（例如分割单值和总值），有点像 `getopt(1)`。

It takes on the standard input the specification of the options to parse and understand, and echoes on the standard output a string suitable for `sh(1)` `eval` to replace the arguments with normalized ones. In case of error, it outputs usage on the standard error stream, and exits with code 129.

Note: Make sure you quote the result when passing it to `eval`. See below for an example.

输入格式
~~~~

'git rev-parse --parseopt' input format is fully text based. It has two parts, separated by a line that contains only `--`. The lines before the separator (should be one or more) are used for the usage. The lines after the separator describe the options.

每行选项的格式如下：

------------
<指定选项><标记>*<参数提示>? SP+ help LF
------------

`<opt-spec>`::
	its format is the short option character, then the long option name separated by a comma. Both parts are not required, though at least one is necessary. May not contain any of the `<flags>` characters. `h,help`, `dry-run` and `f` are examples of correct `<opt-spec>`.

`<标志>`::
	`<标志>` 是 `*`, `=`, `?` 或 `!` 其中一个。
	* 如果选项需要一个参数，则使用 `=`。

	* 使用 `?` 表示选项包含一个可选参数。你可能希望使用 `--stuck-long` 模式来明确地解析可选参数。

	* 使用 `*` 表示该选项不应列在为 `-h` 参数生成的用法中。linkgit:gitcli[7] 中记录了 `--help-all` 的用法。

	* 使用 `!` 不提供相应的否定长选项。

`<参数提示>`::
	`<arg-hint>`, if specified, is used as a name of the argument in the help output, for options that take arguments. `<arg-hint>` is terminated by the first whitespace. It is customary to use a dash to separate words in a multi-word argument hint.

去掉空格后的剩余部分将用作与该选项相关的帮助。

空行将被忽略，不符合此规范的行将用作选项组标题（以空格开头，以便有意创建此类行）。

示例
~~

------------
OPTS_SPEC="\
some-command [<选项>] <参数>...

some-command 会执行 foo 和 bar!
--
h,help! show the help

foo some nifty option --foo bar= some cool option --bar with an argument baz=arg another cool option --baz with a named argument qux?path qux may take a path argument but has meaning by itself

  一个选项组头
C?        带着一个可选参数的 C 选项

eval "$(echo "$OPTS_SPEC" | git rev-parse --parseopt -- "$@" || echo exit $?)"
------------


使用文本
~~~~

当 `"$@"` 为上例中的 `-h`或 `--help` 时，将显示以下使用文本：

------------
usage: some-command [<选项>] <参数>...

    some-command 会执行 foo 和 bar!

    -h, --help            显示磅帮助
    --[no-]foo            一些简便的选项 --foo
    --[no-]bar ...        一些很酷的选项 --bar 带着一个参数
    --[no-]baz <arg>      另外很酷的选项 --baz 带着指定名称的参数
    --[no-]qux[=<路径>]   qux 可能会带上一个对它自己有意义的路径参数

一个选项组的头部
    -C[...]               带着一个可选参数的选项 C
------------

SQ-QUOTE
--------

在 `--sq-quote` 模式下，'git rev-parse' 会在标准输出中输出一行适合 `sh(1)` `eval` 的参数。这一行是通过将 `--sq-quote` 后面的参数规范化而生成的。除了给参数加引号之外，不会做任何其他操作。

如果希望在输出被 shell 引述之前，'git rev-parse' 仍能像往常一样解释命令输入，请参阅 `--sq` 选项。

示例
~~

------------
$ cat >your-git-script.sh <<\EOF
#!/bin/sh
args=$(git rev-parse --sq-quote "$@")   # 引用用户提供的参数
command="git frotz -n24 $args"          # 并手动将它在内部使用
					# 命令行
eval "$command"
EOF

$ sh your-git-script.sh "a b'c"
------------

实例
--

* 打印当前提交的对象名称：
+
------------
$ git rev-parse --verify HEAD
------------

* 在 $REV shell 变量中打印修订版本中的提交对象名称：
+
------------
$ git rev-parse --verify --end-of-options $REV^{commit}
------------
+
如果 $REV 为空或不是有效版本，则会出错。

* 与上述类似：
+
------------
$ git rev-parse --default master --verify --end-of-options $REV
------------
+
但如果 $REV 为空，则会打印 master 中的提交对象名称。

GIT
---
属于 linkgit:git[1] 文档
